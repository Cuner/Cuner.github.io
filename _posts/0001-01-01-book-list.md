---
layout: post
title: "学习清单"
description: "书单以及技能清单"
categories: [bookList]
tags: [bookList]
redirect_from:
  - /0001/01/01/
---
> ### <center>理论基础篇</center>

# 1.网络基础
## 1.1 OSI与TCP/IP 模型
* OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层
* TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层

## 1.2 常见网络服务分层
* 应用层：HTTP、SMTP、DNS、FTP
* 传输层：TCP 、UDP
* 网络层：ICMP 、IP、路由器、防火墙
* 数据链路层：网卡、网桥、交换机
* 物理层：中继器、集线器

## 1.3 TCP
### 1.3.1 三次握手
#### 1.3.1.1 三次握手过程：
* 客户端——发送带有SYN标志的数据包——服务端 一次握手 Client进入syn_sent状态
* 服务端——发送带有SYN/ACK标志的数据包——客户端 二次握手 服务端进入syn_rcvd
* 客户端——发送带有ACK标志的数据包——服务端 三次握手 连接就进入Established状态

#### 1.3.1.2 为什么需要三次：
主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力

#### 1.3.1.3 为什么两次不行：
* 防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源
* 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输，TCP协议的通信双方，都必须维护一个序列号，以标识发送出去的数据包中，哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值，并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手，至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）

### 1.3.2 四次挥手
#### 1.3.2.1 四次挥手过程：
* 客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态
* 服务端收到这个FIN，它发回⼀个ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态（这种状态的含义其实是表示在等待关闭）
* 服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态
* 客户端收到这个FIN，发回ACK报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态（为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接）

#### 1.3.2.2 为什么四次：
​因为需要确保客户端与服务端的数据能够完成传输。

#### 1.3.2.3 如何查看TIME-WAIT状态的链接数量：
netstat -an |grep TIME_WAIT|wc -l 查看连接数等待time_wait状态连接数

#### 1.3.2.4 为什么会TIME-WAIT过多？解决方法是怎样的:
* 可能原因：高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接
* 解决：负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接

### 1.3.3 TCP滑动窗口，拥塞控制
* TCP通过：应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输；

* 拥塞控制目的：为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载

* 拥塞控制过程：TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。

### 1.3.4 TCP粘包原因和解决方法
#### 1.3.4.1 TCP粘包是指：
发送方发送的若干包数据到接收方接收时粘成一包

#### 1.3.4.2 发送方原因：
* TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）：
* 收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题

#### 1.3.4.3 接收方原因：
* TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。

#### 1.3.4.4 ​解决粘包问题：
最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：
* 发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。
* 包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。
* 包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。

## 1.4 TCP与UDP区别及场景

|  类型  |  特点  |  性能  |  应用场景  |  首部字节  |  基于此的协议  |
|  ----  |  ----  |  ----  |  ----  |  ----  |  ----  |
|  TCP  |  面向连接、可靠、字节流  |  传输效率慢、所需资源多  |  文件、邮件传输  |  20-60  |  HTTP、FTP、SMTP  |
|  UDP  |  无连接、不可靠、数据报文段  |  传输效率快、所需资源少  |  语音、视频、直播  |  8个字节  |  RIP、DNS、SNMP  |


## 1.5 HTTP协议
### 1.5.1 HTTP协议1.0_1.1_2.0
* **HTTP1.0**：服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）
* **HTTP1.1**：KeepAlived长连接避免了连接建立和释放的开销；通过Content-Length来判断当前请求数据是否已经全部接受（有状态）
* **HTTP2.0**：引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以并行的传输数据。

#### 1.5.1.1 http1.0和http1.1的主要区别：
​1. 缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）
​2. 网络连接的优化：1.1支持断点续传
​3. 错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态
​4. Host头处理：支持Host头域，不在以IP为请求方标志
​5. 长连接：减少了建立和关闭连接的消耗和延迟。

#### 1.5.1.2 http1.1和http2.0的主要区别：
1. 新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式
2. 多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求）
3. header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的header大小
4. 服务端推送：同google的SPDUY（1.0的一种升级）一样

### 1.5.2 HTTP与HTTPS之间的区别

|  HTTP  |  HTTPS  |
|  ----  |  ----  | 
|  默认端口80  |  HTTPS默认使用端口443  |
|  明文传输、数据未加密、安全性差  |  传输过程ssl加密、安全性较好  |
|  响应速度快、消耗资源少  |  响应速度较慢、消耗资源多、需要用到CA证书  |


#### 1.5.2.1 HTTPS链接建立的过程：
1. 首先客户端先给服务器发送一个请求
2. 服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥
3. 客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密
4. 服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端
5. 随后客户端和服务端就使用对称密钥进行信息传输

#### 1.5.2.2 对称加密算法：
双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES

#### 1.5.2.3 非对称加密算法：
密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA

### 1.5.3 Get和Post请求区别

|  方法  |  描述  |
|  ----  |  ----  | 
|  GET  |  HTTPS默认使用端口443  |
|  POST |  传输过程ssl加密、安全性较好  |
|  PUT  |  响应速度较慢、消耗资源多、需要用到CA证书  |
|  HEAD  |  类似GET请求，返回的响应中没有具体的内容，用于获取报头  |
|  DELETE  |  请求服务器删除指定标识的资源  |
|  OPTIONS  |  可以用来向服务器发送请求来测试服务器的功能性  |
|  TRACE  |  回显服务器收到的请求，用于测试或诊断  |
|  CONNECT  |  HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器  |

**get和post的区别**：

|  差异点  |  get  |  post  |
|  ----  |  ----  |  ----  | 
|  可见性  |  数据在URL中对所有人可见  |  数据不会显示在URL中  |
|  安全性 |  与post相比，get的安全性较差，因为所发送的数据是URL的一部分  |  安全，因为参数不会被保存在浏览器历史或web服务器日志中  |
|  数据长度  |  受限制，最长2kb  |  无限制  |
|  编码类型  |  application/x-www-form-urlencoded  |  multipart/form-data  |
|  缓存  |  能被缓存  |  不能被缓存  |

### 1.5.4 HTTP常见响应状态码
* 100：Continue --- 继续。客户端应继续其请求。
* 200：OK --- 请求成功。一般用于GET与POST请求。
* 301：Moved Permanently --- 永久重定向。
* 302：Found --- 暂时重定向。
* 400：Bad Request --- 客户端请求的语法错误，服务器无法理解。
* 403：Forbideen --- 服务器理解请求客户端的请求，但是拒绝执行此请求。
* 404：Not Found --- 服务器无法根据客户端的请求找到资源（网页）。
* 500：Internal Server Error --- 服务器内部错误，无法完成请求。
* 502：Bad Gateway --- 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。

### 1.5.5 重定向和转发区别
#### 1.5.5.1 重定向(redirect)：
* 地址栏发生变化
* 重定向可以访问其他站点（服务器）的资源
* 重定向是两次请求。不能使用request对象来共享数据

#### 1.5.5.2 ​转发(forward)：
* 转发地址栏路径不变
* 转发只能访问当前服务器下的资源
* 转发是一次请求，可以使用request对象共享数据

### 1.5.6 Cookie和Session区别
* Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：
* Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。
* cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。
* Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态

### 1.5.7 浏览器输入URL过程
**过程**：DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束

|  过程  |  使用的协议  |
|  ----  |  ----  | 
|  1、浏览器查找域名DNS的IP地址DNS查找过程（浏览器缓存、路由器缓存、DNS缓存)  |  DNS：获取域名对应的ip  |
|  2、根据ip建立TCP连接 |  TCP：与服务器建立连接  |
|  3、浏览器向服务器发送HTTP请求  |  HTTP：发送请求  |
|  4、服务器响应HTTP响应  |  HTTP  |
|  5、浏览器进行渲染  |    |


# 2.操作系统基础

## 2.1 进程和线程
* **进程**：是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器
* **线程**：是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题
* **协程**：是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。

## 2.2 进程间通信方式IPC
### 2.2.1 管道pipe：
亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循FIFO，半双工，数据只能单向通信；

### 2.2.2 信号：
信号是一种比较复杂的通信方式，用户调用kill命令将信号发送给其他进程。

### 2.2.3 消息队列：
消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。

### 2.2.4 共享内存(share memory)：
* 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
* 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

### 2.2.5 信号量(Semaphores) ：
信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。

### 2.2.6 套接字(Sockets):
简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。


## 2.3 用户态和核心态
### 2.3.1 用户态：
只能受限的访问内存，运行所有的应用程序

### 2.3.2 核心态：
运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备

### 2.3.3 为什么要有用户态和内核态：
由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络

### 2.3.4 用户态切换到内核态的3种方式：
1. 系统调用：主动调用，系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。
2. 异常：当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常，这时会触发切换内核态处理异常。
3. 外围设备的中断：当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会由用户态到内核态的切换。

## 2.4 操作系统的进程空间
* 栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。
* 堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。
* 静态区（static）—存放全局变量和静态变量的存储
* 代码区(text)—存放函数体的二进制代码。
线程共享堆区、静态区


## 2.5 操作系统内存管理

存管理方式：页式管理、段式管理、段页式管理

### 2.5.1 分段管理：
将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）

### 2.5.2 分页管理：
在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）

### 2.5.3 段页式管理：
段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的

## 2.6 页面置换算法FIFO、LRU
置换算法：先进先出FIFO、最近最久未使用LRU、最佳置换算法OPT

### 2.6.1 先进先出FIFO：
* 缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少

### 2.6.2 最近最久未使用LRU
* 原理：选择最近且最久未使用的页面进行淘汰
* 优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多
* 缺点：没有合适的算法，只有适合的算法，lFU、random都可以

```java
/**
 * @program: Java
 * @description: LRU最近最久未使用置换算法，通过LinkedHashMap实现
 * @author: Mr.Li
 * @create: 2020-07-17 10:29
 **/
public class LRUCache {
    private LinkedHashMap<Integer,Integer> cache;
    private int capacity;   //容量大小

    /**
     *初始化构造函数
     * @param capacity
     */
    public LRUCache(int capacity) {
        cache = new LinkedHashMap<>(capacity);
        this.capacity = capacity;
    }

    public int get(int key) {
        //缓存中不存在此key，直接返回
        if(!cache.containsKey(key)) {
            return -1;
        }

        int res = cache.get(key);
        cache.remove(key);   //先从链表中删除
        cache.put(key,res);  //再把该节点放到链表末尾处
        return res;
    }

    public void put(int key,int value) {
        if(cache.containsKey(key)) {
            cache.remove(key); //已经存在，在当前链表移除
        }
        if(capacity == cache.size()) {
            //cache已满，删除链表头位置
            Set<Integer> keySet = cache.keySet();
            Iterator<Integer> iterator = keySet.iterator();
            cache.remove(iterator.next());
        }
        cache.put(key,value);  //插入到链表末尾
    }
}

```

### 2.6.3 最佳置换算法OPT:
* 原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰
* 优点：具有较好的性能，可以保证获得最低的缺页率
* 缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面）


## 2.7 死锁条件、解决方式
死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象；

### 2.7.1 死锁的条件：
* 互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；
* 请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源
* 非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放
* 循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源

### 2.7.2 解决方法：破坏死锁的任意一条件
* 乐观锁：破坏资源互斥条件，CAS
* 资源一次性分配：从而剥夺请求和保持条件、tryLock
* 可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，数据库deadlock超时
* 资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，转账场景


# 1.3java基础

## 1.3.1 类加载

# 1.4 设计模式


> ### <center>理论提升篇</center>

# java并发编程

# JVM

# 数据结构与算法

# 分布式

> # 工具应用篇
# Sping

# SpingCloud

# 数据库
## Mysql

# 缓存
## Redis

# 搜索引擎
## ES

# 消息队列
## kafaka

# Docker&K8S篇

# netty

# LeeCode




# 附录-资料补充
## 1.书单
- 《Java核心技术(卷1):基础知识(原书第9版)》
- 《Head First设计模式（中文版）》
- 《Spring实战（第四版）》
- 《代码整洁之道》
- 《Java并发编程实战》
- 《从Paxos到Zookeeper分布式一致性原理与实践》
- 《java并发编程的艺术》
- 《Java多线程编程核心技术》
- 《深入理解Java虚拟机：JVM高级特性与最佳实践（第2版）》
- 《算法导论》

## 2.参考链接

# 2 技能清单

## 2.1 java开发
- java并发编程
    - java内存模型
        - https://www.infoq.cn/minibook/java_memory_model
        - http://ifeve.com/java-memory-model-0/
    - 同步容器
    - 同步工具
- java反射
    - https://blog.csdn.net/u012585964/article/details/52011138
    - https://www.sczyh30.com/posts/Java/java-reflection-1/
    - http://wiki.jikexueyuan.com/project/java-reflection/
- java类加载器：
    - https://blog.csdn.net/briblue/article/details/54973413
    - https://blog.csdn.net/ns_code/article/details/17881581
- java动态编译：https://blog.csdn.net/zleven/article/details/54094493

## 2.2 一致性协议
- 2PC
- 3PC
- PAXOS
    - [《Paxos Made Simple》论文翻译](https://www.jianshu.com/p/6d01a8d2df9f)
    - [《Paxos Made Simple》原文](/assets/pdf/paxos-simple1.pdf)
- ZAB(zookeeper)
- RAFT
    - [《In search of an Understandable Consensus Algorithm (Extended Version)》中文翻译](http://www.infoq.com/cn/articles/raft-paper)
    - [《In search of an Understandable Consensus Algorithm (Extended Version)》原文](/assets/pdf/raft.pdf)
    - [Raft Understandable Distributed Consensus](http://thesecretlivesofdata.com/raft/)
    - [raft implementation by Go](https://github.com/coreos/etcd/tree/master/raft#usage)

## 2.3 数据存储与搜索
- MySQL
- Hbase
- Lucene

## 2.4 网络编程
- IO模型

## 2.5 源码

## 2.6 其他
- Spring
- SPI
- ATS:http://blog.sina.com.cn/s/blog_502c8cc40100mw7n.html