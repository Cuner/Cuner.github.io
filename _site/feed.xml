<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.7.4">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2019-11-12T21:30:17+08:00</updated><id>http://localhost:4000/</id><title type="html">Cuner</title><subtitle>No zero day.</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><entry><title type="html">J.U.C之Semaphore</title><link href="http://localhost:4000/blog/2019/11/12/java-concurrent-util-semaphore/" rel="alternate" type="text/html" title="J.U.C之Semaphore" /><published>2019-11-12T00:00:00+08:00</published><updated>2019-11-12T00:00:00+08:00</updated><id>http://localhost:4000/blog/2019/11/12/java-concurrent-util-semaphore</id><content type="html" xml:base="http://localhost:4000/blog/2019/11/12/java-concurrent-util-semaphore/">&lt;p&gt;（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）&lt;/p&gt;

&lt;h1 id=&quot;heading-1-semaphore介绍&quot;&gt;1 Semaphore介绍&lt;/h1&gt;

&lt;p&gt;Semaphore（我们也称之为信号量），是用来控制同时访问特定资源的线程数量，他通过协调各个线程，以保证合理的使用公共资源。Semaphore维护了一个许可集，也就是一定数量的“许可证”。线程在访问公共资源前需要先获取到许可证，许可证数量有限，只有获取到许可证的线程才会被允许继续执行，当剩余可用许可证不足后，尝试获取许可证的线程会被阻塞，等待其他线程释放许可证后再尝试获取许可证。&lt;/p&gt;

&lt;h1 id=&quot;heading-2-semaphore的使用场景&quot;&gt;2 Semaphore的使用场景&lt;/h1&gt;

&lt;p&gt;Semaphore可以用来做流量控制，一般适用于公共资源有限的场景（比如数据库连接、单机服务限流）&lt;/p&gt;

&lt;h1 id=&quot;heading-3-semaphore的使用方式&quot;&gt;3 Semaphore的使用方式&lt;/h1&gt;

&lt;h2 id=&quot;heading-31-初始化&quot;&gt;3.1 初始化&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Semaphore semaphore = new Semaphore(10);

Semaphore semaphore = new Semaphore(10, true);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Semaphore提供一个接受一个int类型的参数作为计数器的构造函数，如果想限制可用许可证的上限为N，这里就传入N。&lt;/p&gt;

&lt;p&gt;Semaphore还提供另外一个构造函数，Semaphore(int permits, boolean fair)，除了传入一个计数值以外，还接受一个boolean传参fair，这个参数决定线程是公平式还是非公平式地获取许可证，默认是非公平。（这里的公平与非公平的获取资源与ReentrantLock公平与非公平的获取锁类似，不再赘述）&lt;/p&gt;

&lt;h2 id=&quot;heading-32-线程获取许可证&quot;&gt;3.2 线程获取许可证&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;semaphore.acquire();

semaphore.acquireUninterruptibly();

semaphore.acquire(2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;当线程尝试获取许可证时，执行acquire()方法。当线程获取到许可证后，方法立即返回，线程继续执行；而当线程未能获取到许可证，线程会被阻塞，等待许可证被释放后重试获取。&lt;/li&gt;
  &lt;li&gt;acquire()方法是对线程中断敏感的，一旦线程在等待获取许可证的过程中被中断，acquire()会抛出中断异常，而如果想要不可中断的获取许可证，即在线程阻塞过程中不会被中断，可使用acquireUninterruptibly()方法来获取许可证&lt;/li&gt;
  &lt;li&gt;如果想要同时获取多个许可证，可在acquire()方法中传入一个int类型的参数，标识你想要获取的许可证数量&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-33-实战说明&quot;&gt;3.3 实战说明&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Test {
    private static Semaphore semaphore = new Semaphore(10);
    private static Executor executor = Executors.newFixedThreadPool(30);
    public static void main(String[] args) {
        for (int i = 0 ; i &amp;lt; 10 ; i++) {
            executor.execute(() -&amp;gt; {
                try {
                    semaphore.acquire();
                    System.out.println(&quot;acquire&quot;);
                    semaphore.release();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }

            });
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;heading-4-实现原理&quot;&gt;4 实现原理&lt;/h1&gt;

&lt;p&gt;与寻常并发工具类类似，Semaphore也是通过继承至AbstractQueuedSynchronized的内部类来实现其功能，基本结构几乎和ReentrantLock完全一样，通过内部类分别实现了公平/非公平策略。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final Sync sync;

abstract static class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 1192457210091910933L;

    Sync(int permits) {
        setState(permits);
    }

    final int getPermits() {
        return getState();
    }

    final int nonfairTryAcquireShared(int acquires) {
        for (;;) {
            int available = getState();
            int remaining = available - acquires;
            if (remaining &amp;lt; 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        }
    }

    protected final boolean tryReleaseShared(int releases) {
        for (;;) {
            int current = getState();
            int next = current + releases;
            if (next &amp;lt; current) // overflow
                throw new Error(&quot;Maximum permit count exceeded&quot;);
            if (compareAndSetState(current, next))
                return true;
        }
    }

    final void reducePermits(int reductions) {
        for (;;) {
            int current = getState();
            int next = current - reductions;
            if (next &amp;gt; current) // underflow
                throw new Error(&quot;Permit count underflow&quot;);
            if (compareAndSetState(current, next))
                return;
        }
    }

    final int drainPermits() {
        for (;;) {
            int current = getState();
            if (current == 0 || compareAndSetState(current, 0))
                return current;
        }
    }
}

/**
 * NonFair version
 */
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -2694183684443567898L;

    NonfairSync(int permits) {
        super(permits);
    }

    protected int tryAcquireShared(int acquires) {
        return nonfairTryAcquireShared(acquires);
    }
}

/**
 * Fair version
 */
static final class FairSync extends Sync {
    private static final long serialVersionUID = 2014338818796000944L;

    FairSync(int permits) {
        super(permits);
    }

    protected int tryAcquireShared(int acquires) {
        for (;;) {
            if (hasQueuedPredecessors())
                return -1;
            int available = getState();
            int remaining = available - acquires;
            if (remaining &amp;lt; 0 ||
                compareAndSetState(available, remaining))
                return remaining;
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;我们可以看到，Semaphore通过两个继承AbstractQueuedSynchronizer的内部类来分别实现公平/非公平地获取同步状态，并且通过实现tryAcquireShared()以及tryReleaseShared()来是实现&lt;strong&gt;&lt;em&gt;共享式&lt;/em&gt;&lt;/strong&gt;地获取同步状态（采用共享式的原因是因为存在多个线程同时获取到同步状态的情况）。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;通过构造器传入的许可证最大可用数来初始化同步状态state，这里的state就代表着可用的许可证数量&lt;/li&gt;
  &lt;li&gt;tryAcquireShared()：通过将同步状态state线程安全的扣减获取许可证的数量来实现共享式获取同步状态，而当可用的许可证不足的时候，获取同步状态失败，返回小于0的状态值，此时线程会被挂起。公平与非公平获取同步状态的区别在于，公平策略在有前驱节点等待获取同步状态的情况下，会默认获取同步状态失败，构造节点放置于等待队列尾部，这样会保证获取同步状态的线程按照顺利依次获取同步状态；而非公平策略则是当有新的线程获取同步状态时，会直接尝试获取同步状态，一定概率下会成功获取同步状态，非公平策略的性能一般优于公平策略，但是无法保证顺序。&lt;/li&gt;
  &lt;li&gt;tryReleaseShared()：通过将同步状态state线程安全的增加释放许可证的数量来实现共享式释放同步状态（因为可能存在多个获取到许可证的线程释放许可证，这里使用compareAndSetState来保障线程安全的数值扣减）&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public Semaphore(int permits) {
    sync = new NonfairSync(permits);
}


public Semaphore(int permits, boolean fair) {
    sync = fair ? new FairSync(permits) : new NonfairSync(permits);
}


public void acquire() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}


public void acquireUninterruptibly() {
    sync.acquireShared(1);
}


public boolean tryAcquire() {
    return sync.nonfairTryAcquireShared(1) &amp;gt;= 0;
}


public boolean tryAcquire(long timeout, TimeUnit unit)
    throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}


public void release() {
    sync.releaseShared(1);
}


public void acquire(int permits) throws InterruptedException {
    if (permits &amp;lt; 0) throw new IllegalArgumentException();
    sync.acquireSharedInterruptibly(permits);
}


public void acquireUninterruptibly(int permits) {
    if (permits &amp;lt; 0) throw new IllegalArgumentException();
    sync.acquireShared(permits);
}


public boolean tryAcquire(int permits) {
    if (permits &amp;lt; 0) throw new IllegalArgumentException();
    return sync.nonfairTryAcquireShared(permits) &amp;gt;= 0;
}


public boolean tryAcquire(int permits, long timeout, TimeUnit unit)
    throws InterruptedException {
    if (permits &amp;lt; 0) throw new IllegalArgumentException();
    return sync.tryAcquireSharedNanos(permits, unit.toNanos(timeout));
}


public void release(int permits) {
    if (permits &amp;lt; 0) throw new IllegalArgumentException();
    sync.releaseShared(permits);
}


public int availablePermits() {
    return sync.getPermits();
}


public int drainPermits() {
    return sync.drainPermits();
}


protected void reducePermits(int reduction) {
    if (reduction &amp;lt; 0) throw new IllegalArgumentException();
    sync.reducePermits(reduction);
}


public boolean isFair() {
    return sync instanceof FairSync;
}


public final boolean hasQueuedThreads() {
    return sync.hasQueuedThreads();
}


public final int getQueueLength() {
    return sync.getQueueLength();
}

protected Collection&amp;lt;Thread&amp;gt; getQueuedThreads() {
    return sync.getQueuedThreads();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Semaphore通过委托模式，将内部功能实现委托了内部类Sync，通过构造函数，传入许可证的数量来初始化同步状态state、传入boolean变量来决定使用公平/非公平策略，并主要提供一下几个方法&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;acquire()：获取一个许可证，当有剩余许可证时返回，当剩余许可证不足时线程被阻塞，直到许可证被释放或者线程被中断&lt;/li&gt;
  &lt;li&gt;acquireUninterruptibly()：获取一个许可证，当有剩余许可证时返回，当剩余许可证不足时线程被阻塞，直到许可证被释放&lt;/li&gt;
  &lt;li&gt;tryAcquire()：尝试获取一个许可证，成功获取返回true，否则返回false&lt;/li&gt;
  &lt;li&gt;tryAcquire(long timeout, TimeUnit unit)：获取一个许可证，当有剩余许可证时返回，当剩余许可证不足时线程被阻塞，直到许可证被释放或者等待获取超时&lt;/li&gt;
  &lt;li&gt;release()：释放一个许可证&lt;/li&gt;
  &lt;li&gt;acquire(int permits)：获取指定数量的许可证，当有足够剩余许可证时返回，当剩余许可证不足时线程被阻塞，直到许可证被释放或者线程被中断&lt;/li&gt;
  &lt;li&gt;acquireUninterruptibly(int permits)：获取指定数量的许可证，当有足够剩余许可证时返回，当剩余许可证不足时线程被阻塞，直到许可证被释放&lt;/li&gt;
  &lt;li&gt;tryAcquire(int permits)：尝试获取指定数量的许可证，成功获取返回true，否则返回false&lt;/li&gt;
  &lt;li&gt;tryAcquire(int permits, long timeout, TimeUnit unit)：获取指定数量的许可证，当有足够剩余许可证时返回，当剩余许可证不足时线程被阻塞，直到许可证被释放或者等待获取超时&lt;/li&gt;
  &lt;li&gt;release(int permits)：释放指定数量的许可证&lt;/li&gt;
  &lt;li&gt;availablePermits()：查询当前可用的许可证数&lt;/li&gt;
  &lt;li&gt;drainPermits()：将当前可用许可证数量设置为0&lt;/li&gt;
  &lt;li&gt;reducePermits(int reduction)：将当前可用许可证减少指定数量&lt;/li&gt;
  &lt;li&gt;hasQueuedThreads()：是否有线程正在等待许可证&lt;/li&gt;
  &lt;li&gt;getQueueLength()：返回正在等待获取许可证的线程数&lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="J.U.C" /><summary type="html">（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）</summary></entry><entry><title type="html">J.U.C之CyclicBarrier</title><link href="http://localhost:4000/blog/2019/11/08/java-concurrent-util-cyclic-barrier/" rel="alternate" type="text/html" title="J.U.C之CyclicBarrier" /><published>2019-11-08T00:00:00+08:00</published><updated>2019-11-08T00:00:00+08:00</updated><id>http://localhost:4000/blog/2019/11/08/java-concurrent-util-cyclic-barrier</id><content type="html" xml:base="http://localhost:4000/blog/2019/11/08/java-concurrent-util-cyclic-barrier/">&lt;p&gt;（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）&lt;/p&gt;

&lt;h1 id=&quot;heading-1-cyclicbarrier介绍&quot;&gt;1 CyclicBarrier介绍&lt;/h1&gt;

&lt;p&gt;CyclicBarrier（我们也称之为同步屏障），是一种同步的工具类。让一组线程在达到各个线程中设置的屏障（同步点）的时候阻塞，直到最后一个线程达到屏障时，屏障才会打开，所有被屏障阻塞的线程才会继续运行。&lt;/p&gt;

&lt;h1 id=&quot;heading-2-cyclicbarrier的使用场景&quot;&gt;2 CyclicBarrier的使用场景&lt;/h1&gt;

&lt;p&gt;一般在一组线程需要相互等待，等待全部线程达到各自的屏障后，线程组中的线程才能继续运行的场景下使用。CyclicBarrier还提供了额外的功能，能够让一组线程全部达到屏障时，&lt;strong&gt;&lt;em&gt;让最后一个到达同步点的线程执行指定的任务。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;h1 id=&quot;heading-3-cyclicbarrier的使用方式&quot;&gt;3 CyclicBarrier的使用方式&lt;/h1&gt;

&lt;h2 id=&quot;heading-31-初始化&quot;&gt;3.1 初始化&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CyclicBarrier barrier = new CyclicBarrier(3);

CyclicBarrier barrier = new CyclicBarrier(3, new Runnable() {
    @Override
    public void run() {
        System.out.println(&quot;hello world&quot;);
    }
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CyclicBarrier提供一个默认的构造函数，接受一个int类型的参数作为计数器，如果想设置N个屏障点（对应屏障拦截的N个线程），这里就传入N &lt;strong&gt;&lt;em&gt;（这里的N必须大于等于0，等于0的时候屏障状态打开）&lt;/em&gt;&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;CyclicBarrier还提供一个更高级的构造函数，CyclicBarrier(int parties, Runnable barrierAction)，用于在所有线程达到屏障后，由最后一个到达屏障的线程执行barrierAction，在此之后，所有线程才能继续运行&lt;/p&gt;

&lt;h2 id=&quot;heading-32-线程标记达到屏障并等待其他线程达到屏障&quot;&gt;3.2 线程标记达到屏障并等待其他线程达到屏障&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;barrier.await();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在每个需要被屏障拦截的线程中执行，标记此处为该线程的屏障，且在其他需要被屏障拦截的线程达到各自的屏障之前被阻塞，由于执行await()之后，线程会被阻塞，所以这里的N个屏障只能分散在N个线程（也就是由N个线程分别执行await方法），在多线程中，需要把这个CyclicBarrier的引用传递到线程中去即可&lt;/p&gt;

&lt;h2 id=&quot;heading-33-实战说明&quot;&gt;3.3 实战说明&lt;/h2&gt;

&lt;p&gt;CyclicBarrier可以用于多线程计算数据，最后合并数据的场景，例如四个线程分别通过计算得到四个数值，最后求和得到最终结果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class CountNumService implements Runnable {

    private CyclicBarrier barrier = new CyclicBarrier(4, this);

    private Executor executor = Executors.newFixedThreadPool(4);

    private ConcurrentHashMap&amp;lt;String, Integer&amp;gt; countMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    public void count() {
        for (int i = 0; i &amp;lt; 4; i++) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    //执行计算过程
                    //存储计算结果
                    countMap.put(Thread.currentThread().getName(), 1);
                    try {
                        barrier.await();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    } catch (BrokenBarrierException e) {
                        e.printStackTrace();
                    }
                }
            });
        }
    }
    
    @Override
    public void run() {
        int result = 0;
        for (Integer num : countMap.values()) {
            result += num;
        }
        System.out.println(&quot;result:&quot; + result);
    }

    public static void main(String[] args) {
        CountNumService countNumService = new CountNumService();
        countNumService.count();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;heading-4-cyclicbarrier与countdownlatch的区别&quot;&gt;4 CyclicBarrier与CountDownLatch的区别&lt;/h1&gt;

&lt;p&gt;我们发现使用CountDownLatch也适用上述的案例：在每个子线程中完成计算任务后执行counDown()，在主线程中执行await()方法，并在此之后执行求和操作&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class CountNumService {

    private CountDownLatch latch = new CountDownLatch(4);

    private Executor executor = Executors.newFixedThreadPool(4);

    private ConcurrentHashMap&amp;lt;String, Integer&amp;gt; countMap = new ConcurrentHashMap&amp;lt;&amp;gt;();

    public void count() {
        for (int i = 0; i &amp;lt; 4; i++) {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    //执行计算过程
                    //存储计算结果
                    countMap.put(Thread.currentThread().getName(), 1);
                    latch.countDown();
                }
            });
        }
        try {
            latch.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        int result = 0;
        for (Integer num : countMap.values()) {
            result += num;
        }
        System.out.println(&quot;result:&quot; + result);
    }

    public static void main(String[] args) {
        CountNumService countNumService = new CountNumService();
        countNumService.count();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;的确如此，在一些等待其他线程执行任务的场景下，使用CountDownLatch与CyclicBarrier都能解决问题，但是两者还是有一定的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;使用CountDownLatch的时候，每个子线程标识完成任务是执行countDown()方法，在此之后线程并不会被阻塞，可以执行下去；而在使用CyclicBarrier的时候，每个子线程标识任务完成（达到屏障）是通过执行await()方法，在此之后线程被阻塞&lt;/li&gt;
  &lt;li&gt;CountDownLatch不能重新初始化，所以只能被使用一次，而CyclicBarrier的计数器可以通过reset()方法重新初始化被循环使用。所以CyclicBarrier能够支持更加复杂的场景，例如发生计算错误的情况，可以重置计数器并让线程重新执行一次。&lt;/li&gt;
  &lt;li&gt;CyclicBarrier还提供其他有用的方法，比如getNumberWaiting()可以获取CyclicBarrier阻塞的线程数量，isBroken()用来获取阻塞的线程是否被中断&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-5-实现原理&quot;&gt;5 实现原理&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class CyclicBarrier {

    //每个barrier实例都会对应一个Genetation实例，而当barrier迭代被循环使用或者重置的时候，Genetation实例会被重新初始化（主要标识是否被中断）
    private static class Generation {
        boolean broken = false;
    }

    private final ReentrantLock lock = new ReentrantLock();
    private final Condition trip = lock.newCondition();
    
    //循环使用时计数器默认大小
    private final int parties;
    
    //所有线程达到屏障后执行的任务
    private final Runnable barrierCommand;
    
    /** The current generation */
    private Generation generation = new Generation();

    //实时计数器，每当线程达到屏障时减一（parties--&amp;gt;0）
    private int count;
    
    
    public CyclicBarrier(int parties, Runnable barrierAction) {
        if (parties &amp;lt;= 0) throw new IllegalArgumentException();
        this.parties = parties;
        this.count = parties;
        this.barrierCommand = barrierAction;
    }

    public CyclicBarrier(int parties) {
        this(parties, null);
    }
    
    public int await() throws InterruptedException, BrokenBarrierException {
        try {
            return dowait(false, 0L);
        } catch (TimeoutException toe) {
            throw new Error(toe); // cannot happen
        }
    }

    public int await(long timeout, TimeUnit unit)
        throws InterruptedException,
               BrokenBarrierException,
               TimeoutException {
        return dowait(true, unit.toNanos(timeout));
    }

    //使用ReentrantLock的Condition的await()方法使得到达屏障的线程阻塞
    private int dowait(boolean timed, long nanos)
        throws InterruptedException, BrokenBarrierException,
               TimeoutException {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            final Generation g = generation;

            if (g.broken)
                throw new BrokenBarrierException();

            if (Thread.interrupted()) {
                breakBarrier();
                throw new InterruptedException();
            }

            int index = --count;
            if (index == 0) {  // tripped
                boolean ranAction = false;
                try {
                    final Runnable command = barrierCommand;
                    if (command != null)
                        command.run();//当最后一个线程到达屏障时，执行构造器传入的Runnable任务后打开屏障
                    ranAction = true;
                    nextGeneration();
                    return 0;
                } finally {
                    if (!ranAction)
                        breakBarrier();
                }
            }

            // loop until tripped, broken, interrupted, or timed out
            for (;;) {
                try {
                    if (!timed)
                        trip.await();
                    else if (nanos &amp;gt; 0L)
                        nanos = trip.awaitNanos(nanos);
                } catch (InterruptedException ie) {
                    if (g == generation &amp;amp;&amp;amp; ! g.broken) {
                        breakBarrier();
                        throw ie;
                    } else {
                        // We're about to finish waiting even if we had not
                        // been interrupted, so this interrupt is deemed to
                        // &quot;belong&quot; to subsequent execution.
                        Thread.currentThread().interrupt();
                    }
                }

                if (g.broken)
                    throw new BrokenBarrierException();

                if (g != generation)
                    return index;

                if (timed &amp;amp;&amp;amp; nanos &amp;lt;= 0L) {
                    breakBarrier();
                    throw new TimeoutException();
                }
            }
        } finally {
            lock.unlock();
        }
    }
    
    private void breakBarrier() {
        generation.broken = true;
        count = parties;
        trip.signalAll();
    }
    
    public void reset() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            breakBarrier();   // break the current generation
            nextGeneration(); // start a new generation
        } finally {
            lock.unlock();
        }
    }

    private void nextGeneration() {
        // signal completion of last generation
        trip.signalAll();
        // set up next generation
        count = parties;
        generation = new Generation();
    }

    public int getParties() {
        return parties;
    }
    
    public boolean isBroken() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return generation.broken;
        } finally {
            lock.unlock();
        }
    }


    public int getNumberWaiting() {
        final ReentrantLock lock = this.lock;
        lock.lock();
        try {
            return parties - count;
        } finally {
            lock.unlock();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;与CountDownLatch不同，CyclicBarrier直接将内部实现委托给了ReentrantLock，在到达屏障点的时候执行Condition.await()方法阻塞当前线程，当最后一个线程达到屏障的时候执行Condition.notifyAll()方法唤醒所有线程。&lt;/li&gt;
  &lt;li&gt;当某个阻塞的线程中断或者超时后，唤醒所有线程，且所有线程都抛出相对应的异常&lt;/li&gt;
  &lt;li&gt;当最后一个线程到达屏障之后，会去执行构造是传入的可执行任务，然后计数器复位开始下一次循环迭代。&lt;/li&gt;
  &lt;li&gt;reset()方法执行后，唤醒所有等待的子线程，然后计数器复位开始下一次循环迭代。&lt;/li&gt;
&lt;/ul&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="J.U.C" /><summary type="html">（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）</summary></entry><entry><title type="html">J.U.C之CountDownLatch</title><link href="http://localhost:4000/blog/2019/11/06/java-concurrent-util-count-down-latch/" rel="alternate" type="text/html" title="J.U.C之CountDownLatch" /><published>2019-11-06T00:00:00+08:00</published><updated>2019-11-06T00:00:00+08:00</updated><id>http://localhost:4000/blog/2019/11/06/java-concurrent-util-count-down-latch</id><content type="html" xml:base="http://localhost:4000/blog/2019/11/06/java-concurrent-util-count-down-latch/">&lt;p&gt;（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）&lt;/p&gt;

&lt;h1 id=&quot;heading-1-countdownlatch介绍&quot;&gt;1 CountDownLatch介绍&lt;/h1&gt;

&lt;p&gt;CountDownLatch（我们也称之为闭锁），是一种同步的工具类。类似于一扇门：在闭锁到达结束状态之前，这扇门一直是关闭着的，不允许任何线程通过，当到达结束状态时，这扇门会打开并允许所有的线程通过。且当门打开了，就永远保持打开状态&lt;/p&gt;

&lt;h1 id=&quot;heading-2-countdownlatch的使用场景&quot;&gt;2 CountDownLatch的使用场景&lt;/h1&gt;

&lt;p&gt;一般在需要等待其他多个指定任务执行完成的场景下使用，这里的多个任务可以分散在不同的线程中执行。最常见的场景：主线程需要等待其他子线程执行完成后才能继续执行，而一般上述的场景我们能在主线程中使用thread.join()来实现，相比来说CountDownLatch也能解决该问题，同时它更具有灵活性，它允许一个或多个线程等待其他线程完成某个特殊的操作&lt;/p&gt;

&lt;h1 id=&quot;heading-3-countdownlatch的使用方式&quot;&gt;3 CountDownLatch的使用方式&lt;/h1&gt;

&lt;h2 id=&quot;heading-31-初始化&quot;&gt;3.1 初始化&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;CountDownLatch latch = new CountDownLatch(3);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CountDownLatch的构造函数接受一个int类型的参数作为计数器，如果想等待N个操作执行完成打开闭锁，这里就传入N（这里的N必须大于等于0，等于0的时候闭锁状态打开）。&lt;/p&gt;

&lt;h2 id=&quot;heading-32-标记某个被等待的操作执行完成&quot;&gt;3.2 标记某个被等待的操作执行完成&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;latch.countDown();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在某个需要被等待的操作执行完成之后，执行这行代码，标识操作完成，当我们调用countDown()方法时，构造时候传入的N就会减1，由于countDown()方法可以使用在任何地方，所以这里被等待的N个操作，可以分散在N个不同的线程中，也可以是一个线程中的N个步骤。用在多线程中，只需要把这个CountDownLatch的引用传递到线程中去即可&lt;/p&gt;

&lt;h2 id=&quot;heading-33-等待n个操作执行完成&quot;&gt;3.3 等待N个操作执行完成&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;latch.await();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;CountDownLatch的await()方法会阻塞当前线程，直到构造时候传入的N减少至0。另外await()方法支持传入指定时间，这个方法等待指定时间后，就不会阻塞当前线程&lt;/p&gt;

&lt;h2 id=&quot;heading-34-注意&quot;&gt;3.4 注意&lt;/h2&gt;

&lt;p&gt;CountDownLatch不可能重新初始化或者修改内部计数N的值。&lt;/p&gt;

&lt;h1 id=&quot;heading-4-实现原理&quot;&gt;4 实现原理&lt;/h1&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private static final class Sync extends AbstractQueuedSynchronizer {
    private static final long serialVersionUID = 4982264981922014374L;

    Sync(int count) {
        setState(count);
    }

    int getCount() {
        return getState();
    }

    protected int tryAcquireShared(int acquires) {
        return (getState() == 0) ? 1 : -1;
    }

    protected boolean tryReleaseShared(int releases) {
        // Decrement count; signal when transition to zero
        for (;;) {
            int c = getState();
            if (c == 0)
                return false;
            int nextc = c-1;
            if (compareAndSetState(c, nextc))
                return nextc == 0;
        }
    }
}

private final Sync sync;

public CountDownLatch(int count) {
    if (count &amp;lt; 0) throw new IllegalArgumentException(&quot;count &amp;lt; 0&quot;);
    this.sync = new Sync(count);
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;闭锁CountDownLatch是J.U.C中的同步工具类，采用委托模式委托给了实现AbstractQueuedSynchronizer的同步器子类Sync，且采用了共享式同步状态的获取与释放（因为这里会存在多个线程同时调用await方法，在等待闭锁打开后获取同步状态）。首先使用CountDownLatch初始化传入的N来设置同步器Sync的同步状态state为N，仅当同步状态减少到0的时候才允许共享式获取同步状态，而当释放同步状态时，将state的值线程安全的递减1（因为存在多个等待的操作同时完成，这里用到了compareAndSetState方法保证线程安全）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
public void await() throws InterruptedException {
    sync.acquireSharedInterruptibly(1);
}

public boolean await(long timeout, TimeUnit unit)
    throws InterruptedException {
    return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));
}

public void countDown() {
    sync.releaseShared(1);
}

public long getCount() {
    return sync.getCount();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;CountDownLatch把countDown()方法委托给了同步器Sync的releaseShared()方法–共享式的释放同步状态方法&lt;/li&gt;
  &lt;li&gt;CountDownLatch把await()方法委托给了同步器Sync的acquireSharedInterruptibly()方法–共享式可中断的获取同步状态方法&lt;/li&gt;
  &lt;li&gt;CountDownLatch把await(long timeout, TimeUnit unit)方法委托给了同步器Sync的tryAcquireSharedNanos()方法–共享式超时中断的获取同步状态&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;使用CountDownLatch，在await()的过程中，线程会被挂起，相比线程自主轮训判断更节省CPU资源&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="J.U.C" /><summary type="html">（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）</summary></entry><entry><title type="html">J.U.C之ConcurrentHashMap</title><link href="http://localhost:4000/blog/2019/10/10/java-concurrent-util-concurrent-hash-map/" rel="alternate" type="text/html" title="J.U.C之ConcurrentHashMap" /><published>2019-10-10T00:00:00+08:00</published><updated>2019-10-10T00:00:00+08:00</updated><id>http://localhost:4000/blog/2019/10/10/java-concurrent-util-concurrent-hash-map</id><content type="html" xml:base="http://localhost:4000/blog/2019/10/10/java-concurrent-util-concurrent-hash-map/">&lt;h1 id=&quot;heading-1-concurrenthashmap-vs-hashmap--hashtable&quot;&gt;1 ConcurrentHashMap VS HashMap &amp;amp; HashTable&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;多线程环境下，HashMap是非线程安全的，使用HashMap进行put操作会导致链表形成环形数据接口，最终导致死循环，导致CPU利用率达100%。（形成环形数据结构的过程见文章结尾附录）&lt;/li&gt;
  &lt;li&gt;HashTab使用synchronized同步锁来保证线程安全，所以在线程竞争激烈的情况下，HashTable的效率非常低下&lt;/li&gt;
  &lt;li&gt;􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹ConcurrentHashMap使用分段锁技术，有效提升了并发访问效率。（容器里面维护了很多锁，每一把锁用于锁容器中的一部分数据，当多线程访问容器中不同数据段的数据时，就不会产生锁竞争，从而有效提高并发访问效率）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-2-concurrenthashmap的结构&quot;&gt;2 ConcurrentHashMap的结构&lt;/h1&gt;
&lt;p&gt;链表 NODE&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static class Node&amp;lt;K,V&amp;gt; implements Map.Entry&amp;lt;K,V&amp;gt; {
	final int hash;
	final K key;
	volatile V val;
	volatile Node&amp;lt;K,V&amp;gt; next;

	Node(int hash, K key, V val, Node&amp;lt;K,V&amp;gt; next) {
		this.hash = hash;
		this.key = key;
		this.val = val;
		this.next = next;
	}

	public final K getKey()       { return key; }
	public final V getValue()     { return val; }
	public final int hashCode()   { return key.hashCode() ^ val.hashCode(); }
	public final String toString(){ return key + &quot;=&quot; + val; }
	public final V setValue(V value) {
		throw new UnsupportedOperationException();
	}

	public final boolean equals(Object o) {
		Object k, v, u; Map.Entry&amp;lt;?,?&amp;gt; e;
		return ((o instanceof Map.Entry) &amp;amp;&amp;amp;
				(k = (e = (Map.Entry&amp;lt;?,?&amp;gt;)o).getKey()) != null &amp;amp;&amp;amp;
				(v = e.getValue()) != null &amp;amp;&amp;amp;
				(k == key || k.equals(key)) &amp;amp;&amp;amp;
				(v == (u = val) || v.equals(u)));
	}

	/**
	 * Virtualized support for map.get(); overridden in subclasses.
	 */
	Node&amp;lt;K,V&amp;gt; find(int h, Object k) {
		Node&amp;lt;K,V&amp;gt; e = this;
		if (k != null) {
			do {
				K ek;
				if (e.hash == h &amp;amp;&amp;amp;
						((ek = e.key) == k || (ek != null &amp;amp;&amp;amp; k.equals(ek))))
					return e;
			} while ((e = e.next) != null);
		}
		return null;
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;其中find()方法，按序遍历链表获取元素&lt;/p&gt;

&lt;h1 id=&quot;heading-附录多线程场景下hashmap的死循环&quot;&gt;附录：多线程场景下hashMap的死循环&lt;/h1&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="J.U.C" /><summary type="html">1 ConcurrentHashMap VS HashMap &amp;amp; HashTable 多线程环境下，HashMap是非线程安全的，使用HashMap进行put操作会导致链表形成环形数据接口，最终导致死循环，导致CPU利用率达100%。（形成环形数据结构的过程见文章结尾附录） HashTab使用synchronized同步锁来保证线程安全，所以在线程竞争激烈的情况下，HashTable的效率非常低下 􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹􏲅􏳫􏵆􏳨􏳩􏳬􏳬􏳧􏵆􏳪􏷡􏰩􏷝􏴚􏲉􏰩􏴛􏰜􏳅􏳍􏺛􏰔􏲫􏱜􏱃􏺭􏳛􏺢􏰎􏰏􏴪􏰚􏺹ConcurrentHashMap使用分段锁技术，有效提升了并发访问效率。（容器里面维护了很多锁，每一把锁用于锁容器中的一部分数据，当多线程访问容器中不同数据段的数据时，就不会产生锁竞争，从而有效提高并发访问效率）</summary></entry><entry><title type="html">J.U.C之Lock</title><link href="http://localhost:4000/blog/2018/12/27/java-concurrent-util-lock/" rel="alternate" type="text/html" title="J.U.C之Lock" /><published>2018-12-27T00:00:00+08:00</published><updated>2018-12-27T00:00:00+08:00</updated><id>http://localhost:4000/blog/2018/12/27/java-concurrent-util-lock</id><content type="html" xml:base="http://localhost:4000/blog/2018/12/27/java-concurrent-util-lock/">&lt;p&gt;（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）&lt;/p&gt;

&lt;h1 id=&quot;heading-1-lock接口&quot;&gt;1 Lock接口&lt;/h1&gt;
&lt;p&gt;锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但有些锁支持多个线程同时访问共享资源，如读写锁）。在Lock接口出现之前，java程序是靠synchronized关键字实现锁功能的。在java SE5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用的时候需要显式的获取跟释放锁。虽然它缺少了隐式获取和释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、非阻塞获取锁、可中断获取锁以及超时获取锁等多种特性。&lt;/p&gt;

&lt;h2 id=&quot;heading-11-lock接口的api&quot;&gt;1.1 Lock接口的API&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;void lock()&lt;/strong&gt;&lt;br /&gt;
获取锁，调用该方法当前线程将会获取锁，当获取锁后，从该方法返回&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;void lockInterruptibly() throws InterruptedException&lt;/strong&gt;&lt;br /&gt;
可中断的获取锁，和lock()方法不同在于该方法可以响应中断，即在锁获取中可中断当前线程&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;boolean tryLock()&lt;/strong&gt;&lt;br /&gt;
尝试非阻塞获取锁，调用该方法后立刻返回，如果能获取到锁则返回true，否则返回false&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;boolean tryLock(long time, TimeUnit unit) throws InterruptedException&lt;/strong&gt;&lt;br /&gt;
超时获取锁，当前线程在以下三种情况下返回
    &lt;ul&gt;
      &lt;li&gt;当前线程获取到了锁，返回true&lt;/li&gt;
      &lt;li&gt;当前线程在超时时间内被中断，抛出InterruptedException异常&lt;/li&gt;
      &lt;li&gt;获取超时时间结束，返回false&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;void unlock()&lt;/strong&gt;&lt;br /&gt;
释放锁&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Condition newCondition()&lt;/strong&gt;&lt;br /&gt;
获取等待通知组件，该组件和当前的锁绑定，当前线程只有获取了锁，才能调用该组件的await方法，而调用后，当前线程将释放锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-2-重入锁reentrantlock&quot;&gt;2 重入锁ReentrantLock&lt;/h1&gt;
&lt;p&gt;顾名思义，就是支持重进入的锁，它表示该锁支持一个线程对资源重复加锁。除此之外，该锁还支持获取锁时的公平与非公平性选择。&lt;/p&gt;

&lt;h2 id=&quot;heading-21-使用示例&quot;&gt;2.1 使用示例&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lock lock = new ReentrantLock();
lock.lock();
try {
    //相关操作
} finally {
    lock.unlock();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;heading-22-实现重进入&quot;&gt;2.2 实现重进入&lt;/h2&gt;
&lt;p&gt;重进入是指任意线程在获取锁之后能够再次获取该锁而不被阻塞，该特性的实现需要解决以下两个问题&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;同一线程再次获取锁：锁需要识别获取锁的线程是够为当前占据锁的线程，如果是，则再次获取成功。&lt;/li&gt;
  &lt;li&gt;锁的最终释放：线程重复n次获取了锁，随后在第n次释放锁之后，其他线程才能获取到锁。锁的最终释放要求锁对于获取进行计数自增，计数表示当前锁被重复获取的次数，而锁被释放时，计数自减，当计数为0时表示锁已经释放&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;ReentrantLock是通过委托给继承队列同步器的静态内部类，来实现（非）公平锁的获取与释放，以非公平性（默认）的实现为例，获取以及释放同步状态的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean nonfairTryAcquire(int acquires) {
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) {
        if (compareAndSetState(0, acquires)) {
            setExclusiveOwnerThread(current);
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) {
        int nextc = c + acquires;
        if (nextc &amp;lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    }
    return false;
}

protected final boolean tryRelease(int releases) {
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread())
        throw new IllegalMonitorStateException();
    boolean free = false;
    if (c == 0) {
        free = true;
        setExclusiveOwnerThread(null);
    }
    setState(c);
    return free;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;nonfairTryAcquire()方法：增加了线程再次获取同步状态的处理逻辑：通过判断当前线程是否是获取锁的线程来决定获取同步状态是否成功，如果是获取锁的线程再次请求获取锁，则将同步状态值增加并返回true，表示获取同步状态成功。其中同步状态值即为线程重复获取锁的次数。（这里自增的操作因为是单线程，所以不需要考虑同步的问题）。  &lt;br /&gt;
tryRelease()方法：每次释放锁则将同步状态值自减，只有当同步状态完全释放了，才能返回true。可以看到该方法将同步状态值是否为0作为最终释放条件，当同步状态值为0，将占有线程置为null，并返回true，表示释放成功。（这里释放过程同样也不会产生线程竞争）&lt;/p&gt;

&lt;h2 id=&quot;heading-23-公平性与非公平性锁&quot;&gt;2.3 公平性与非公平性锁&lt;/h2&gt;
&lt;p&gt;如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最先获取锁。事实上公平性锁机制往往没有非公平的效率高，但是公平性锁的优势在于能够减少“饥饿”发生的概率。&lt;/p&gt;

&lt;p&gt;在ReentrantLock中，根据公平锁以及非公平锁获取获取锁顺序的区别，分别实现了两个静态内部类（继承AbstractQueuedSynchronized），并把锁的获取委托给它们。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * Sync object for non-fair locks
 */
static final class NonfairSync extends Sync {
    private static final long serialVersionUID = 7316153563782823691L;

    /**
     * Performs lock.  Try immediate barge, backing up to normal
     * acquire on failure.
     */
    final void lock() {
        if (compareAndSetState(0, 1))
            setExclusiveOwnerThread(Thread.currentThread());
        else
            acquire(1);
    }

    protected final boolean tryAcquire(int acquires) {
        return nonfairTryAcquire(acquires);
    }
}

/**
 * Sync object for fair locks
 */
static final class FairSync extends Sync {
    private static final long serialVersionUID = -3000897897090466540L;

    final void lock() {
        acquire(1);
    }

    /**
     * Fair version of tryAcquire.  Don't grant access unless
     * recursive call or no waiters or is first.
     */
    protected final boolean tryAcquire(int acquires) {
        final Thread current = Thread.currentThread();
        int c = getState();
        if (c == 0) {
            if (!hasQueuedPredecessors() &amp;amp;&amp;amp;
                    compareAndSetState(0, acquires)) {
                setExclusiveOwnerThread(current);
                return true;
            }
        }
        else if (current == getExclusiveOwnerThread()) {
            int nextc = c + acquires;
            if (nextc &amp;lt; 0)
                throw new Error(&quot;Maximum lock count exceeded&quot;);
            setState(nextc);
            return true;
        }
        return false;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;对于非公平锁，线程请求锁的时候直接尝试获取同步状态，只要CAS设置同步状态成功，那么当前线程则获取到了锁；而公平锁不同，与nonfairTryAcquire()方法相比较，唯一不同的地方是判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该方法返回true，则表示有线程比当前线程更先请求锁，因此不能直接尝试获取锁，需要构造同步节点加入到同步队列中，等待前驱节点获取并释放锁后才能去尝试获取同步状态。&lt;/p&gt;

&lt;h1 id=&quot;heading-3-读写锁&quot;&gt;3 读写锁&lt;/h1&gt;

&lt;p&gt;读写锁维护了一对锁，一个读锁和一个写锁，分别对应共享锁和排它锁。简单来说，当某个线程获取到了写锁，其他线程无法再去获取写锁或者读锁；当某个线程获取到了读锁，其他线程无法再去获取写锁，允许再去获取读锁。读写锁通过读写分离，除了保证写操作对读操作的可见性之外，在读多于写的情况下，还能提供更好的并发性和吞吐量。&lt;/p&gt;

&lt;h2 id=&quot;heading-31-读写锁的特性&quot;&gt;3.1 读写锁的特性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;公平性选择&lt;/li&gt;
  &lt;li&gt;重进入&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;锁降级&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;前两点特性与ReentrantLock一致，而锁降级特性是遵循获取写锁、获取读锁在释放写锁的次序，写锁能够降级成为读锁。&lt;/p&gt;

&lt;h2 id=&quot;heading-32-读写锁的示例&quot;&gt;3.2 读写锁的示例&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Cache {
    private static Map&amp;lt;String, Object&amp;gt; map = new HashMap&amp;lt;&amp;gt;();
    private static ReentrantReadWriteLock readWriteLock = new ReentrantReadWriteLock();
    private static Lock readLock = readWriteLock.readLock();
    private static Lock writeLock = readWriteLock.writeLock();

    //获取map中某个key对应的value
    public static Object get(String key) {
        readLock.lock();
        try {
            return map.get(key);
        } finally {
            readLock.unlock();
        }
    }

    //设置某个key对应的value，并返回旧的value
    public static void set(String key, Object value) {
        writeLock.lock();
        try {
            map.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述示例中，Cache组合了一个非线程安全的HashMap作为缓存的实现，同时使用读写锁来保证Cache是线程安全的。在读操作中，需要获取读锁，这使得并发读取时不会相互阻塞；写操作中需要获取写锁，获取到写锁后，其他线程对于读锁或者写锁的获取均被阻塞。Cache使用读写锁保证了读操作的并发性，也保证了每次写操作对所有的读写操作的可见性。&lt;/p&gt;

&lt;h2 id=&quot;heading-33-读写锁实现分析&quot;&gt;3.3 读写锁实现分析&lt;/h2&gt;

&lt;h3 id=&quot;heading-331-读写锁的实现结构&quot;&gt;3.3.1 读写锁的实现结构&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ReentrantReadWriteLock对外封装了获取读锁与写锁的方法，这里的读锁与写锁都实现了锁接口Lock&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public ReentrantReadWriteLock(boolean fair) {
    sync = fair ? new FairSync() : new NonfairSync();
    readerLock = new ReadLock(this);
    writerLock = new WriteLock(this);
}
    
public ReentrantReadWriteLock.WriteLock writeLock() { return writerLock; }
public ReentrantReadWriteLock.ReadLock  readLock()  { return readerLock; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;ReentrantReadWrite通过委托给继承队列同步器AQS的静态内部类（FairSync/NonfairSync），来实现（非）公平锁的获取与释放&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;abstract static class Sync extends AbstractQueuedSynchronizer {...}
static final class NonfairSync extends Sync {...}
static final class FairSync extends Sync {...}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;写锁的获取与释放，委托给Sync类独占式的获取与释放同步状态&lt;/li&gt;
  &lt;li&gt;读锁的获取与释放，委托给Sync类共享式的获取与释放同步状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heading-332-读写状态的设计&quot;&gt;3.3.2 读写状态的设计&lt;/h3&gt;

&lt;p&gt;读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是同步器的同步状态。因此同步状态值需要区分读写锁的获取，同时也要考虑都线程重入的情况。 &lt;br /&gt;
读写锁将同步状态值分成了两个部分，高16位表示读，低16位表示写。于是写状态等于S &amp;amp; ((1 &amp;lt;&amp;lt;&amp;lt; 16) - 1)，即将高16为全部抹去，读状态等于S &amp;gt;&amp;gt;&amp;gt; 16（无符号补0右移16位）&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final int SHARED_SHIFT   = 16;
static final int SHARED_UNIT    = (1 &amp;lt;&amp;lt; SHARED_SHIFT);
static final int MAX_COUNT      = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;
static final int EXCLUSIVE_MASK = (1 &amp;lt;&amp;lt; SHARED_SHIFT) - 1;

/** Returns the number of shared holds represented in count  */
static int sharedCount(int c)    { return c &amp;gt;&amp;gt;&amp;gt; SHARED_SHIFT; }
/** Returns the number of exclusive holds represented in count  */
static int exclusiveCount(int c) { return c &amp;amp; EXCLUSIVE_MASK; }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;heading-333-写锁的获取与释放&quot;&gt;3.3.3 写锁的获取与释放&lt;/h3&gt;
&lt;p&gt;写锁是一个支持重进入的排他锁。如果当前线程已经获取了死锁，则增加写状态。如果当前线程在获取写锁时，读锁已经被获取（代码中的 c != 0 &amp;amp;&amp;amp; w == 0）或者该线程不是已经获取写锁的线程，则获取同步状态失败，当前线程进入到等待状态。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected final boolean tryAcquire(int acquires) {
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) {
        // (Note: if c != 0 and w == 0 then shared count != 0)
        if (w == 0 || current != getExclusiveOwnerThread())
            return false;
        if (w + exclusiveCount(acquires) &amp;gt; MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        // Reentrant acquire
        setState(c + acquires);
        return true;
    }
    if (writerShouldBlock() ||
        !compareAndSetState(c, c + acquires))
        return false;
    setExclusiveOwnerThread(current);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;写锁的释放与ReentrantLock释放锁的过程基本一致，每次释放减少同步状态，当写状态为0时则表示写锁被释放。&lt;/p&gt;

&lt;h3 id=&quot;heading-334-读锁的获取与释放&quot;&gt;3.3.4 读锁的获取与释放&lt;/h3&gt;

&lt;p&gt;读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问时，读锁总能被成功获取，此时需要线程安全的增加读状态。如果当前线程在获取读锁时，写锁已经被其他线程获取，则该线程进入等待状态。这里读锁的获取释放代码做了部分删减（删减掉了每个线程维护各自获取读锁次数的相关代码）。&lt;/p&gt;

&lt;p&gt;在tryReleaseShared()方法中，如果其他线程已经获取了写锁，则当前线程获取读锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，依靠CAS）增加读状态，成功获取锁。&lt;/p&gt;

&lt;p&gt;可以看到这里有个fullTryAcquireShared()方法，其中的for循环主要应对多个线程同时获取共享式同步状态导致CAS失败的重试。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protected final int tryAcquireShared(int unused) {
    Thread current = Thread.currentThread();
    int c = getState();
    if (exclusiveCount(c) != 0 &amp;amp;&amp;amp;
        getExclusiveOwnerThread() != current)
        return -1;
    int r = sharedCount(c);
    if (!readerShouldBlock() &amp;amp;&amp;amp;
        r &amp;lt; MAX_COUNT &amp;amp;&amp;amp;
        compareAndSetState(c, c + SHARED_UNIT)) {
        return 1;
    }
    return fullTryAcquireShared(current);
}

final int fullTryAcquireShared(Thread current) {
    HoldCounter rh = null;
    for (;;) {
        int c = getState();
        if (exclusiveCount(c) != 0) {
            if (getExclusiveOwnerThread() != current)
                return -1;
        } else if (readerShouldBlock()) {
            return -1;
        }
        if (sharedCount(c) == MAX_COUNT)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        if (compareAndSetState(c, c + SHARED_UNIT)) {
            return 1;
        }
    }
}

protected final boolean tryReleaseShared(int unused) {
    Thread current = Thread.currentThread();
    for (;;) {
        int c = getState();
        int nextc = c - SHARED_UNIT;
        if (compareAndSetState(c, nextc))
            return nextc == 0;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;heading-335-公平性与非公平性的选择&quot;&gt;3.3.5 公平性与非公平性的选择&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final class NonfairSync extends Sync {
    private static final long serialVersionUID = -8159625535654395037L;
    final boolean writerShouldBlock() {
        return false; // writers can always barge
    }
    final boolean readerShouldBlock() {
        return apparentlyFirstQueuedIsExclusive();//队列中第一个等待的节点是否为独占式
    }
}

static final class FairSync extends Sync {
    private static final long serialVersionUID = -2274990926593161451L;
    final boolean writerShouldBlock() {
        return hasQueuedPredecessors();//是否有前驱节点
    }
    final boolean readerShouldBlock() {
        return hasQueuedPredecessors();
    }
}

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;heading-336-锁降级&quot;&gt;3.3.6 锁降级&lt;/h3&gt;

&lt;p&gt;锁降级是指写锁降级成读锁。如果当前线程拥有写锁，然后将其释放，最后在获取读锁，这种分段过程不能称之为锁降级。锁降级是指把持住当前拥有的写锁，再获取到读锁，随后释放先前拥有的写锁的过程。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void process() {
    readLock.lock();
    if (update) {
        //需要写入，此时释放掉读锁
        readLock.unlock();
        //锁降级过程从写锁获取开始
        writeLock.lock();
        try {
            if (update) {
                //准备数据写入
                update = false;
            }
            readLock.lock();
        } finally {
            writeLock.unlock();
        }
        //锁降级完成，写锁降级为读锁
    }
    try {
        //读取数据
    } finally {
        readLock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当数据发生变更后，update（布尔类型且被volatile修饰）变量被置为true，此时所有访问process()方法的线程都将感知到变更，但只有一个线程能够获取到写锁，其他线程会被阻塞在读锁或者写锁的lock()方法上。当前线程获取写锁完成数据准备之后，在获取读锁，随后释放写锁，完成锁降级。&lt;/p&gt;

&lt;p&gt;锁降级过程中再次获取读锁是为了保证数据的可见性，避免在次过程中，其他线程的写入操作使得当前线程无法感知&lt;/p&gt;

&lt;p&gt;在前面获取锁的代码中可以看到，在获取到读锁的时候，如果当前线程已经获取到写锁，这个时候读锁是会被成功获取的；而获取写锁的时候，当前线程获取到了读锁，这个时候线程将被阻塞，处于等待状态。可以得知ReenTrantReadWriteLock支持锁降级，而不支持锁升级（把持读锁，获取写锁，释放读锁的过程）。目的也是为了保障可见性，如果读锁已经被多个线程获取，其中任意线程获取了写锁并更新了数据，则器更新的数据对其他获取读锁的线程是不可见的。&lt;/p&gt;

&lt;h1 id=&quot;heading-4-condition接口&quot;&gt;4 Condition接口&lt;/h1&gt;

&lt;p&gt;我我们知道，任何一个Java都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()、notifyAll()方法，这些方法与synchronized同步关键字配合使用，可以实现等待通知模式。Condition接口也提供了类型Object监视器方法，与Lock配合可以实现等待通知模式。但是两者在使用方式以及功能特性上还是有一些区别的。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;对比项&lt;/th&gt;
      &lt;th&gt;Object Monitor Methods&lt;/th&gt;
      &lt;th&gt;Condition&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;前置条件&lt;/td&gt;
      &lt;td&gt;获取对象锁&lt;/td&gt;
      &lt;td&gt;调用Lock.lock()获取锁，调用lock.newCondition()获取Condition对象&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;等待队列个数&lt;/td&gt;
      &lt;td&gt;一个&lt;/td&gt;
      &lt;td&gt;多个&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;当前线程释放锁进入等待状态&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;当前线程释放锁进入等待状态，在等待状态中不响应中断&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;当前线程释放锁进入超时等待状态&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;当前线程释放锁进入等待状态到将来的某个时间点&lt;/td&gt;
      &lt;td&gt;不支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;唤醒等待队列中的一个线程&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;唤醒等待队列中的全部线程&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
      &lt;td&gt;支持&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;实现Condition接口的ConditionObject类是在AbstractQueuedSynchronized中定义的，但是ConditionObject的使用都是与Lock绑定使用的，因此放到这里来讲。&lt;/p&gt;

&lt;h2 id=&quot;heading-41-condition接口&quot;&gt;4.1 Condition接口&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;void await() throws InterruptedException&lt;/strong&gt;&lt;br /&gt;
当前线程进入等待状态，直到被通知或者中断。如果当前线程从await()方法返回，那么表明该线程已经获取了Condition对象所对应的锁。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;void awaitUninterruptibly()&lt;/strong&gt;&lt;br /&gt;
当前线程进入等待状态直到被通知，该方法对中断不敏感&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;long awaitNanos(long nanosTimeout) throws InterruptedException&lt;/strong&gt;   &lt;br /&gt;
当前线程进入等待状态，直到被通知、中断或者超时。返回值表示剩余的时间，如果返回值小于等于0，表示等待超时&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;boolean awaitUntil(Date deadline) throws InterruptedException&lt;/strong&gt; &lt;br /&gt;
当前线程进入等待状态，直到被通知、中断或者到某个时间点。如果没有到指定时间就被通知，方法返回true，否则表示已经到了指定时间还未被通知，此时返回false。&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;void signal()&lt;/strong&gt;  &lt;br /&gt;
唤醒一个等待在Condition上的线程，该线程从等待时间返回前必须获得与Condition相关联的锁&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;void signalAll()&lt;/strong&gt; &lt;br /&gt;
唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获取与Condition相关联的锁&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-42-condition实例&quot;&gt;4.2 Condition实例&lt;/h2&gt;

&lt;p&gt;Condition定义了等待通知两种类型的方法，当线程调用终这些方法时，需要提前获取到Condition对象关联的锁。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Lock lock = new ReentrantLock();
Condition condition = lock.newCondition();
public void conditionWait() throws InterruptedException {
    lock.lock();
    try {
        condition.await();
    } finally {
        lock.unlock();
    }
}

public void conditionSignl() {
    lock.lock();
    try {
        condition.signal();
    } finally {
        lock.unlock();
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;当调用await()方法后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal()方法后，通知当前线程后，当前线程从await()方法返回，并且在返回前已经获取到了锁。&lt;/p&gt;

&lt;h2 id=&quot;heading-43-condition实现分析&quot;&gt;4.3 Condition实现分析&lt;/h2&gt;

&lt;h3 id=&quot;heading-431-等待队列&quot;&gt;4.3.1 等待队列&lt;/h3&gt;
&lt;p&gt;ConditionObject是同步器AbstractQueuedSynchronizer的内部类，每个Condition对象都包含一个等待队列，该队列是Conditon实现等待通知功能的关键。&lt;/p&gt;

&lt;p&gt;等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造等待节点加入等待队列并进入等待状态。这里的节点复用了同步器中的节点，也就是说，同步队列以及等待队列中的节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。&lt;/p&gt;

&lt;p&gt;一个Condition包含一个等待队列，Condition拥有首节点（firstWaiter）和尾节点（lastWaiter）。在Object监视器上，一个对象拥有一个同步队列和等待队列，而并发包中的Lock拥有一个同步队列和多个等待队列。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/post/2018-12-27-java-concurrent-util-lock/waitQueue.jpg&quot; width=&quot;800px&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;heading-432-等待&quot;&gt;4.3.2 等待&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void await() throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    // 当前线程加入等待队列
    Node node = addConditionWaiter();
    // 释放锁
    int savedState = fullyRelease(node);
    int interruptMode = 0;
    // 阻塞线程
    while (!isOnSyncQueue(node)) {
        // 解除阻塞
        LockSupport.park(this);
        if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)
            break;
    }
    // 自旋尝试获取同步状态
    if (acquireQueued(node, savedState) &amp;amp;&amp;amp; interruptMode != THROW_IE)
        interruptMode = REINTERRUPT;
    if (node.nextWaiter != null) // clean up if cancelled
        unlinkCancelledWaiters();
    if (interruptMode != 0)
        reportInterruptAfterWait(interruptMode);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;该方法的线程成功获取到了锁，也就是同步队列中的首节点。该方法将会以当前线程构造新的等待节点（addConditionWaiter()方法），并将节点从尾部加入等待队列，同时释放锁，唤醒同步队列中的后继节点，最后当前线程会进入等待状态。Condition拥有首尾节点的引用，而新增节点只需要将原有的尾节点lastWaiter指向它，并且更新尾节点即可。上述节点引用更新的过程并没有使用CAS保证，原因在于调用await()方法的线程必定是获取了锁的线程，也就是说该过程是线程安全的。&lt;/p&gt;

&lt;p&gt;当等待队列中的节点被唤醒，则唤醒的线程开始尝试获取同步状态，如果等待线程被中断会抛出InterruptedException。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/post/2018-12-27-java-concurrent-util-lock/addToWaitQueue.jpg&quot; width=&quot;800px&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;heading-433-通知&quot;&gt;4.3.3 通知&lt;/h2&gt;

&lt;p&gt;调用Condition中的signal()方法，将会唤醒等待队列中的等待时间最长的节点（也就是首节点），在唤醒节点之前，会将节点移动到同步队列中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void signal() {
    if (!isHeldExclusively())
        throw new IllegalMonitorStateException();
    Node first = firstWaiter;
    if (first != null)
        doSignal(first);
}

private void doSignal(Node first) {
    do {
        if ( (firstWaiter = first.nextWaiter) == null)
            lastWaiter = null;
        first.nextWaiter = null;
    } while (!transferForSignal(first) &amp;amp;&amp;amp;
            (first = firstWaiter) != null);
}

final boolean transferForSignal(Node node) {
    // 修改节点状态，恢复到默认状态
    if (!compareAndSetWaitStatus(node, Node.CONDITION, 0))
        return false;
    // 加入到同步队列
    Node p = enq(node);
    int ws = p.waitStatus;
    if (ws &amp;gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))
        // 唤醒等待状态
        LockSupport.unpark(node.thread);
    return true;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;调用该方法的前置条件是当前线程必须获取到了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列中的首节点，将其移动到同步队列并用LockSupport唤醒节点中的线程。&lt;/p&gt;

&lt;p&gt;通过调用同步器的enq()方法，等待队列中的首节点线程安全的加入到同步队列。当节点移动到同步队列之后，当前线程再唤醒等待线程。&lt;/p&gt;

&lt;p&gt;被唤醒后的线程，将从await()方法中的while循环中退出（节点已经在同步队列中，isOnSyncQueue()方法返回true），进而调用同步器的acquireQueued()方法加入到获取同步状态的竞争中。&lt;/p&gt;

&lt;p&gt;成功获取同步状态之后，被唤醒的线程将先从先前调用的await()方法中返回，此时该线程已经成功地获取了锁。&lt;/p&gt;

&lt;p&gt;Condition的signalAll()方法，相当于对等待队列中的每一个节点均进行一次signal()方法，效果就是将等待队列中的所有节点移动到同步队列中，并唤醒每个节点的线程&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/post/2018-12-27-java-concurrent-util-lock/backToSynQueue.jpg&quot; width=&quot;800px&quot; /&gt;&lt;/center&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="J.U.C" /><summary type="html">（读此篇前建议完成《J.U.C之AbstractQueuedSynchronizer》的阅读）</summary></entry><entry><title type="html">J.U.C之AbstractQueuedSynchronizer</title><link href="http://localhost:4000/blog/2018/11/09/java-concurrent-util-AQS/" rel="alternate" type="text/html" title="J.U.C之AbstractQueuedSynchronizer" /><published>2018-11-09T00:00:00+08:00</published><updated>2018-11-09T00:00:00+08:00</updated><id>http://localhost:4000/blog/2018/11/09/java-concurrent-util-AQS</id><content type="html" xml:base="http://localhost:4000/blog/2018/11/09/java-concurrent-util-AQS/">&lt;h1 id=&quot;heading-1-简介&quot;&gt;1 简介&lt;/h1&gt;
&lt;p&gt;队列同步器AbstractQueuedSynchronizer（简称同步器），是用来构建同步组件（包括同步容器以及同步工具）的基本框架，也是java.concurrent.util包的实现核心。它使用了一个volatile int类型的成员变量来表示同步状态（J.U.C同样提供了AbstractQueuedLongSynchronizer，它使用long类型的成员变量来表示同步状态），通过内置的FIFO队列来完成资源的获取线程的排队工作。
同步器的主要使用方式是继承，子类通过继承同步器并实现抽象方法来管理同步状态（基于模本方法模式）。子类被推荐定义为自定义同步组件的静态内部类（作为代理配合实现同步组件），同步器自身没有实现任何同步接口，它仅仅定义了同步状态的获取与释放来供自定义同步组件使用，同步器既可以独占式的获取同步状态也可以共享式的获取同步状态。&lt;/p&gt;

&lt;h1 id=&quot;heading-2-队列同步器的接口&quot;&gt;2 队列同步器的接口&lt;/h1&gt;
&lt;p&gt;同步器的设计是基于模板方法模式的，子类需要继承同步器并重写指定的方法，而后将同步器组合在自定义同步组件的实现中（委托模式），并调用同步器的模板方法，这些模板方法将会调用同步器子类中重写的方法&lt;/p&gt;

&lt;h2 id=&quot;heading-21-访问修改同步状态&quot;&gt;2.1 访问、修改同步状态&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;int getState()：获取当前同步状态&lt;/li&gt;
  &lt;li&gt;void setState(int newState)：设置当前同步状态&lt;/li&gt;
  &lt;li&gt;boolean compareAndSetState(int expect, int update)：使用CAS设置当前同步状态&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-22-同步器可重写方法&quot;&gt;2.2 同步器可重写方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;独占式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;boolean tryAcquire(int arg)：独占式获取同步状态，实现该方法需要查询当前同步状态并判断是否符合预期，然后同步CAS设置同步状态。&lt;/li&gt;
  &lt;li&gt;boolean tryRelease(int arg)：独占式释放同步状态，等待获取同步状态的线程将有机会获取同步状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;共享式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;int tryAcquireShared(int arg)：共享式获取同步状态，返回大于等于0表示获取成功（其中0代表此前没有线程共享式获取同步状态，大于0表示已有其他线程获取到了同步状态），反之获取失败。&lt;/li&gt;
  &lt;li&gt;boolean tryReleaseShared(int arg)：共享式释放同步状态。&lt;/li&gt;
  &lt;li&gt;boolean isHeldExclusively()：当前同步器是否被当前线程独占&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-23-同步器提供的模板方法&quot;&gt;2.3 同步器提供的模板方法&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;独占式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;void acquire(int arg)：独占式获取同步状态，如果当前线程获取同步状态成功，则返回，否则将会进入同步队列等待，该方法将会调用重写的tryAcquire(int arg)方法&lt;/li&gt;
  &lt;li&gt;void acquireInterruptibly(int arg)：与acquire(int arg)方法相同，但是该方法响应中断，当前线程未获取到同步状态而进入到同步队列中，如果当前线程被中断，则抛出InterruptedException并返回。&lt;/li&gt;
  &lt;li&gt;boolean tryAcquireNanos(int arg, long nanosTimeout)：在acquireInterruptibly(int arg)基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，那么将返回false，如果获取到了则返回true。&lt;/li&gt;
  &lt;li&gt;boolean release(int arg)：独占式的释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;共享式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;void acquireShared(int arg)：共享式的获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的获取主要区别在于同一时刻能够有多个线程获取到同步状态。&lt;/li&gt;
  &lt;li&gt;void acquireSharedInterruptibly(int arg)：与acquireShared(int arg)方法相同，该方法响应中断。&lt;/li&gt;
  &lt;li&gt;boolean tryAcquireSharedNanos(int arg, long nanosTimeout)：在acquireSharedInterruptibly(int arg)方法的基础上增加了超时限制。&lt;/li&gt;
  &lt;li&gt;boolean releaseShared(int arg)：共享式的释放同步状态。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;查询同步队列中等待线程情况&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Thread getFirstQueuedThread()：获取在同步队列中等待的第一个线程。&lt;/li&gt;
  &lt;li&gt;boolean isQueued(Thread thread)：判断该线程是否处于同步队列中。&lt;/li&gt;
  &lt;li&gt;boolean apparentlyFirstQueuedIsExclusive()：判断同步队列中的第一个线程是否在等待独占式获取同步状态&lt;/li&gt;
  &lt;li&gt;final boolean hasQueuedPredecessors()：同步队列中，当前线程对应的节点是否有前驱节点。&lt;/li&gt;
  &lt;li&gt;int getQueueLength()：获取同步队列长度。&lt;/li&gt;
  &lt;li&gt;Collection&lt;Thread&gt; getQueuedThreads()：获取等待在同步队列上的线程集合。&lt;/Thread&gt;&lt;/li&gt;
  &lt;li&gt;Collection&lt;Thread&gt; getExclusiveQueuedThreads()：获取等待在同步队列上等待独占式获取同步状态的线程集合。&lt;/Thread&gt;&lt;/li&gt;
  &lt;li&gt;Collection&lt;Thread&gt; getSharedQueuedThreads()：获取等待在同步队列上等待共享式获取同步状态的线程集合。&lt;/Thread&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-3-队列同步器的实现分析&quot;&gt;3 队列同步器的实现分析&lt;/h1&gt;

&lt;h2 id=&quot;heading-31-同步队列&quot;&gt;3.1 同步队列&lt;/h2&gt;
&lt;p&gt;同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成一个节点（Node），并将其加入到同步队列中，同时会阻塞当前线程，当同步状态释放时，会把前驱节点为首节点的节点中的线程唤醒，使其再次尝试获取同步状态。&lt;/p&gt;

&lt;h3 id=&quot;heading-311-节点&quot;&gt;3.1.1 节点&lt;/h3&gt;
&lt;p&gt;同步队列中的节点（Node）用来保存获取同步状态失败的线程引用、等待状态以及前驱和后继节点。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;static final class Node {
    static final Node SHARED = new Node();//标识共享式节点，对应的线程等待共享式获取同步状态
    static final Node EXCLUSIVE = null;//标识独占式节点，对应的线程等待独占式获取同步状态

    /** waitStatus value to indicate thread has cancelled */
    /** 由于在同步队列中等待的线程等待超时或被中断，需要从队列中取消等待，节点进入该状态后将不会变化 */
    static final int CANCELLED =  1;
    
    /** waitStatus value to indicate successor's thread needs unparking */
    /** 后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行 */
    static final int SIGNAL    = -1;
    
    /** waitStatus value to indicate thread is waiting on condition */
    /** 节点在等待队列中，节点的线程在等待condition上，当其他线程对Condition调用了signal()方法后，该节点将会从等待队列中转移到同步队列中，加入到对同步状态的获取中 */
    static final int CONDITION = -2;
    
    /**
     * waitStatus value to indicate the next acquireShared should
     * unconditionally propagate
     */
     /** 表示下一次共享式同步状态获取将会无条件地被传播下去 */
    static final int PROPAGATE = -3;
    
    volatile int waitStatus;//对应上述多种状态值，其中0表示初始值
    
    volatile Node prev;//前驱节点

    volatile Node next;//后继节点

    volatile Thread thread;//获取同步状态的线程

    Node nextWaiter;//等待队列中的后继节点。在同步队列中，该字段用来标识当前节点的类型（共享or独占）

    final boolean isShared() {
        return nextWaiter == SHARED;
    }

    final Node predecessor() throws NullPointerException {
        Node p = prev;
        if (p == null)
            throw new NullPointerException();
        else
            return p;
    }

    Node() {    // Used to establish initial head or SHARED marker
    }

    Node(Thread thread, Node mode) {     // Used by addWaiter
        this.nextWaiter = mode;
        this.thread = thread;
    }

    Node(Thread thread, int waitStatus) { // Used by Condition
        this.waitStatus = waitStatus;
        this.thread = thread;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;关于节点的状态state变化：当节点被创建，状态值默认为0；当有后继节点在等待，节点状态会被置为-1（SINGAL）；当节点共享式获取到同步状态且后继节点为共享式节点，该节点状态会被设置为-3（PROPAGATE）；当节点获取同步状态超时或者被中断，节点状态将被置为1（CANCELLED）。&lt;/p&gt;

&lt;p&gt;主意：Node节点不仅用在同步队列中，AbstractQueuedSynchronizer中的Condition中的等待队列也是使用Node节点构建，所以其中有些字段在两种队列的共用，需要注意区分，Condition将在后面介绍ReenTrantLock的文章中阐述。&lt;/p&gt;

&lt;h3 id=&quot;heading-312-队列&quot;&gt;3.1.2 队列&lt;/h3&gt;
&lt;p&gt;节点是构成同步队列的基础，同步器拥有首节点（head）和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;同步队列的基本结构&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;同步器包含了两个节点类型的引用，一个指向首节点，一个指向尾节点。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/post/2018-11-09-java-concurrent-util-AQS/queue.jpg&quot; width=&quot;500px&quot; /&gt;&lt;/center&gt;

&lt;ul&gt;
  &lt;li&gt;节点加入到同步队列中&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;当一个线程成功的获取了同步状态，其他线程无法获取到同步状态，需要被构造成节点并加入到同步队列中，而加入这个队列的过程必须保证是线程安全的，因此同步器提供了一个基于CAS设置尾节点的方法：compareAndSetTail(Node expect, Node update)。&lt;/p&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/post/2018-11-09-java-concurrent-util-AQS/setTail.jpg&quot; width=&quot;500px&quot; /&gt;&lt;/center&gt;

&lt;ul&gt;
  &lt;li&gt;首节点的设置
同步队列遵循FIFO，首节点是获取同步状态成功的节点，首节点的线程在释放同步状态时，会唤醒后继节点，而后继节点将会在获取同步状态成功的同时将自己设置为首节点，由于只有一个线程能获取到同步状态，因此头结点的设置不需要CAS来保证。&lt;/li&gt;
&lt;/ul&gt;

&lt;center&gt;&lt;img src=&quot;/assets/images/post/2018-11-09-java-concurrent-util-AQS/setHead.jpg&quot; width=&quot;500px&quot; /&gt;&lt;/center&gt;

&lt;h2 id=&quot;heading-32-独占式同步状态的获取与释放&quot;&gt;3.2 独占式同步状态的获取与释放&lt;/h2&gt;

&lt;h3 id=&quot;heading-321-acquire方法&quot;&gt;3.2.1 acquire方法&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void acquire(int arg) {
    if (!tryAcquire(arg) &amp;amp;&amp;amp;
            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
        selfInterrupt();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;上述代码主要完成了同步状态获取、节点构造、加入同步队列以及再同步队列中自旋等待等相关工作：首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法保证线程安全地获取同步状态，如果同步状态获取失败，则构造独占式同步节点，并通过addWaiter(Node node)方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node, int arg)方法，使得该节点以“死循环”的方式获取同步状态（这里我们也叫做自旋）。如果获取不到则阻塞当前线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Node addWaiter(Node mode) {
    Node node = new Node(Thread.currentThread(), mode);
    // Try the fast path of enq; backup to full enq on failure
    Node pred = tail;
    if (pred != null) {
        node.prev = pred;
        if (compareAndSetTail(pred, node)) {
            pred.next = node;
            return node;
        }
    }
    enq(node);
    return node;
}

private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;节点进入同步队列之后，就进入了一个自旋的过程，每个节点都在观察自己，当条件满足且获取到了同步状态之后，就从这个自旋状态退出。值得注意的是该方法对中断不敏感。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final boolean acquireQueued(final Node node, int arg) {
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();//1.获取前驱节点
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {//2.前驱节点是首节点时 尝试获取同步状态
                setHead(node);//3.获取同步状态成功后，将自己设置为首节点
                p.next = null; // help GC
                failed = false;
                return interrupted;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

/** 当获取同步状态失败后 是否需要阻塞当前线程：
当前驱节点等待状态是SIGNAL时，返回true */
private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) {
    int ws = pred.waitStatus;
    if (ws == Node.SIGNAL)
        return true;
    if (ws &amp;gt; 0) {
        do {//处理等待状态为删除的节点
            node.prev = pred = pred.prev;
        } while (pred.waitStatus &amp;gt; 0);
        pred.next = node;
    } else {
        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);
    }
    return false;
}

/** 阻塞当前线程并检查是否中断 */
private final boolean parkAndCheckInterrupt() {
    LockSupport.park(this);//阻塞当前线程
    return Thread.interrupted();
}

/** 取消当前线程获取同步状态的操作：
1.如果需要取消的节点是尾节点，将尾节点指向前驱节点
2.如果需要取消的节点属于中间节点（前驱节点不是首节点），将前驱节点的next指向后继节点（越过当前节点）
3.上述两种case是为了订正next指针，通过后续唤醒后继节点，在shouldParkAfterFailedAcquire方法中订正pre指针
*/
private void cancelAcquire(Node node) {
    if (node == null)
        return;

    node.thread = null;

    // Skip cancelled predecessors
    Node pred = node.prev;
    while (pred.waitStatus &amp;gt; 0)
        node.prev = pred = pred.prev;

    Node predNext = pred.next;

    node.waitStatus = Node.CANCELLED;

    // If we are the tail, remove ourselves.
    if (node == tail &amp;amp;&amp;amp; compareAndSetTail(node, pred)) {
        compareAndSetNext(pred, predNext, null);
    } else {
        // If successor needs signal, try to set pred's next-link
        // so it will get one. Otherwise wake it up to propagate.
        int ws;
        if (pred != head &amp;amp;&amp;amp;
                ((ws = pred.waitStatus) == Node.SIGNAL ||
                        (ws &amp;lt;= 0 &amp;amp;&amp;amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;amp;&amp;amp;
                pred.thread != null) {
            Node next = node.next;
            if (next != null &amp;amp;&amp;amp; next.waitStatus &amp;lt;= 0)
                compareAndSetNext(pred, predNext, next);
        } else {
            unparkSuccessor(node);//唤醒后继节点
        }

        node.next = node; // help GC
    }
}

/** 唤醒后继节点 */
private void unparkSuccessor(Node node) {
    int ws = node.waitStatus;
    if (ws &amp;lt; 0)
        compareAndSetWaitStatus(node, ws, 0);
        
    Node s = node.next;
    if (s == null || s.waitStatus &amp;gt; 0) {
        s = null;
        for (Node t = tail; t != null &amp;amp;&amp;amp; t != node; t = t.prev)
            if (t.waitStatus &amp;lt;= 0)
                s = t;
    }
    if (s != null)
        LockSupport.unpark(s.thread);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;头节点是成功获取同步状态的节点，每当新的节点获取到同步状态后，该节点就会被设置为首节点，而头节点释放同步状态后，将会唤醒后继节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否为首节点，这样也保证了队列的“先进先出”原则&lt;/p&gt;

&lt;h3 id=&quot;heading-322-acquireinterruptibly方法&quot;&gt;3.2.2 acquireInterruptibly方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void acquireInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (!tryAcquire(arg))
        doAcquireInterruptibly(arg);
}

private void doAcquireInterruptibly(int arg)
        throws InterruptedException {
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return;
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;acquireInterruptibly方法与acquire方法基本一致，只是在检查到中断后抛出InterruptedException。&lt;/p&gt;

&lt;h3 id=&quot;heading-323-tryacquirenanos方法&quot;&gt;3.2.3 tryAcquireNanos方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean tryAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquire(arg) ||
            doAcquireNanos(arg, nanosTimeout);
}

private boolean doAcquireNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (nanosTimeout &amp;lt;= 0L)
        return false;
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head &amp;amp;&amp;amp; tryAcquire(arg)) {
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return true;
            }
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout &amp;lt;= 0L)
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    nanosTimeout &amp;gt; spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;tryAcquireNanos方法方法与acquireInterruptibly方法基本一致，只是增加了超时失败的机制。&lt;/p&gt;

&lt;h3 id=&quot;heading-324-release方法&quot;&gt;3.2.4 release方法&lt;/h3&gt;
&lt;p&gt;当前线程获取同步状态并执行了响应逻辑之后，就需要释放同步状态，使得后续节点能够获取到同步状态。通过调用同步器的release方法可以释放同步状态，该方法在释放了同步状态之后，会唤醒后继节点，进而使后继节点重新尝试获取同步状态。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean release(int arg) {
    if (tryRelease(arg)) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;主要是调用unparkSuccessor方法唤醒阻塞中的后继节点，唤醒后的后继节点会开始尝试获取同步状态。&lt;/p&gt;

&lt;h2 id=&quot;heading-33-共享式同步状态的获取与释放&quot;&gt;3.3 共享式同步状态的获取与释放&lt;/h2&gt;

&lt;h3 id=&quot;heading-331-acquireshared方法&quot;&gt;3.3.1 acquireShared方法&lt;/h3&gt;
&lt;p&gt;共享式获取与独占式获取的最主要区别在于同一时刻能否有多个线程同时获取到同步状态。通过调用acquireShared方法能够共享式的获取同步状态。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void acquireShared(int arg) {
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireShared(arg);
}

private void doAcquireShared(int arg) {
    final Node node = addWaiter(Node.SHARED);//1.新增SHARED类型的节点
    boolean failed = true;
    try {
        boolean interrupted = false;
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);//2.设置头节点并唤醒后继节点(因为共享式获取同步状态的特点，如果后继节点也是共享式节点，允许后继节点直接获取同步状态)
                    p.next = null; // help GC
                    if (interrupted)
                        selfInterrupt();
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                interrupted = true;
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}

private void setHeadAndPropagate(Node node, int propagate) {
    Node h = head; // Record old head for check below
    setHead(node);

    //试图通知首节点的后继节点
    if (propagate &amp;gt; 0 || h == null || h.waitStatus &amp;lt; 0 ||
            (h = head) == null || h.waitStatus &amp;lt; 0) {
        Node s = node.next;
        if (s == null || s.isShared())
            doReleaseShared();
    }
}

private void doReleaseShared() {
    for (;;) {
        Node h = head;
        if (h != null &amp;amp;&amp;amp; h != tail) {
            int ws = h.waitStatus;
            if (ws == Node.SIGNAL) {
                if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0))
                    continue;            // loop to recheck cases
                unparkSuccessor(h);//唤醒后继节点
            }
            else if (ws == 0 &amp;amp;&amp;amp;
                    !compareAndSetWaitStatus(h, 0, Node.PROPAGATE))
                continue;                // loop on failed CAS
        }
        if (h == head)                   // loop if head changed
            break;
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在acquireShared方法中，同步器调用tryAcquireShared方法尝试获取同步状态，tryAcquireShared方法返回值类型为int，当返回值大于等于0则代表能获取到同步状态（当返回值为0则代表只有当前节点共享式获取到了同步状态）。
acquireShared方法与acquire方法的区别主要在于当获取到同步状态之后，除了将自身设置为首节点之外，还需要试图告知后继节点，允许共享式获取同步状态。（这里的doReleaseShared试图唤醒共享式节点）&lt;/p&gt;

&lt;h3 id=&quot;heading-332-acquiresharedinterruptibly方法&quot;&gt;3.3.2 acquireSharedInterruptibly方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final void acquireSharedInterruptibly(int arg)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    if (tryAcquireShared(arg) &amp;lt; 0)
        doAcquireSharedInterruptibly(arg);
}

private void doAcquireSharedInterruptibly(int arg)
        throws InterruptedException {
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return;
                }
            }
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    parkAndCheckInterrupt())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;acquireSharedInterruptibly方法与acquireShared方法基本一致，只是在检查到中断后抛出InterruptedException。&lt;/p&gt;

&lt;h3 id=&quot;heading-333-tryacquiresharednanos方法&quot;&gt;3.3.3 tryAcquireSharedNanos方法&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (Thread.interrupted())
        throw new InterruptedException();
    return tryAcquireShared(arg) &amp;gt;= 0 ||
            doAcquireSharedNanos(arg, nanosTimeout);
}

private boolean doAcquireSharedNanos(int arg, long nanosTimeout)
        throws InterruptedException {
    if (nanosTimeout &amp;lt;= 0L)
        return false;
    final long deadline = System.nanoTime() + nanosTimeout;
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try {
        for (;;) {
            final Node p = node.predecessor();
            if (p == head) {
                int r = tryAcquireShared(arg);
                if (r &amp;gt;= 0) {
                    setHeadAndPropagate(node, r);
                    p.next = null; // help GC
                    failed = false;
                    return true;
                }
            }
            nanosTimeout = deadline - System.nanoTime();
            if (nanosTimeout &amp;lt;= 0L)
                return false;
            if (shouldParkAfterFailedAcquire(p, node) &amp;amp;&amp;amp;
                    nanosTimeout &amp;gt; spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            if (Thread.interrupted())
                throw new InterruptedException();
        }
    } finally {
        if (failed)
            cancelAcquire(node);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;tryAcquireSharedNanos方法与acquireSharedInterruptibly方法基本一致，只是增加了超时失败的机制。&lt;/p&gt;

&lt;h3 id=&quot;heading-334-releaseshared方法&quot;&gt;3.3.4 releaseShared方法&lt;/h3&gt;
&lt;p&gt;该方法在释同步状态后，将会唤醒处于等待状态的节点。它和独占式主要区别在于该方法必须保证同步状态被安全释放，因为释放同步状态的操作会同时来自多个线程。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public final boolean releaseShared(int arg) {
    if (tryReleaseShared(arg)) {
        doReleaseShared();
        return true;
    }
    return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;heading-4-番外篇关于节点加入到同步队列中的同步操作&quot;&gt;4 番外篇：关于节点加入到同步队列中的同步操作&lt;/h2&gt;
&lt;p&gt;当新的节点加入到同步队列中，其实是包含的两个操作的，一个是将新节点的pre指针指向尾节点，一个是将tail指针指向新节点，而AbstractQueuedSynchronizer是通过CAS来保证同步的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Node enq(final Node node) {
    for (;;) {
        Node t = tail;
        if (t == null) { // Must initialize
            if (compareAndSetHead(new Node()))
                tail = head;
        } else {
            node.prev = t;
            if (compareAndSetTail(t, node)) {
                t.next = node;
                return t;
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;主要逻辑再else方法块里面，通过循环以及CAS操作来保证这两个操作的同步，否则会因为并发加入节点，导致队列错乱。写者在阅读《java多线程编程核心技术》学习到了一种非阻塞算法，感叹精妙之余分享如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private Node enq(final Node node) {
    while(true) {
        Node curTail = tail;
        Node tailNext = curTail.next;
        if (curTail == tail) {
            if (tailNext != null) {
                //队列处于中间状态，推进尾节点
                compareAndSetTail(curTail, tailNext);
            } else {
                //处于稳定状态 尝试插入新节点
                if (compareAndSetNext(curTail, null, Node)) {
                    Node.pre = curTail;
                    //插入成功，推进尾节点
                    compareAndSetTail(curTail, Node);
                    return true;
                }
            }
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;其中compareAndSetTail方法以及compareAndSetTail方法都是AbstractQueuedSynchronizer自带方法&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="J.U.C" /><summary type="html">1 简介 队列同步器AbstractQueuedSynchronizer（简称同步器），是用来构建同步组件（包括同步容器以及同步工具）的基本框架，也是java.concurrent.util包的实现核心。它使用了一个volatile int类型的成员变量来表示同步状态（J.U.C同样提供了AbstractQueuedLongSynchronizer，它使用long类型的成员变量来表示同步状态），通过内置的FIFO队列来完成资源的获取线程的排队工作。 同步器的主要使用方式是继承，子类通过继承同步器并实现抽象方法来管理同步状态（基于模本方法模式）。子类被推荐定义为自定义同步组件的静态内部类（作为代理配合实现同步组件），同步器自身没有实现任何同步接口，它仅仅定义了同步状态的获取与释放来供自定义同步组件使用，同步器既可以独占式的获取同步状态也可以共享式的获取同步状态。</summary></entry><entry><title type="html">paxos与raft一致性协议</title><link href="http://localhost:4000/blog/2018/10/21/raft-diff-paxos/" rel="alternate" type="text/html" title="paxos与raft一致性协议" /><published>2018-10-21T00:00:00+08:00</published><updated>2018-10-21T00:00:00+08:00</updated><id>http://localhost:4000/blog/2018/10/21/raft-diff-paxos</id><content type="html" xml:base="http://localhost:4000/blog/2018/10/21/raft-diff-paxos/">&lt;h1 id=&quot;heading-1-一致性协议&quot;&gt;1 一致性协议&lt;/h1&gt;
&lt;p&gt;一致性协议简单来说，是一种保障集群中所有机器上的数据达到一致的协议。最直观的最好理解的一致性协议，例如2PC、3PC，便是在做数据操作时，对集群中的所有机器同时做数据操作，仅当集群中的全部机器操作成功后，所有机器保证一致后，该数据操作才成功，否则只要有一台机器因为网络等其他原因导致数据操作失败，该数据操作就会失败，其他操作成功的机器也会全部进行数据回滚。
上述一致性协议虽然简单，但相对保守，且无法应对机器宕机、网络分区等故障问题。针对这种情况，paxos以及raft等一致性协议应运而生。
新一代的一致性协议有如下特点：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;采取过半原则：即当集群中大于一半的机器认同该数据操作，且数据操作成功后，该数据操作被集群认可（因为任何两个多数派集合中至少有一个成员是公共的）&lt;/li&gt;
  &lt;li&gt;允许集群中出现部分机器不一致性，且时刻异步进行着机器之间数据的同步&lt;/li&gt;
  &lt;li&gt;选举出leader协助集群中机器间数据的同步&lt;/li&gt;
  &lt;li&gt;在出现机器宕机或者网络分区后，集群仍能正常工作，且保证集群一致性，同时当机器重启或者网络恢复后，也能保证集群一致性（利用持久化数据存储）&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-2-paxos以及raft介绍&quot;&gt;2 paxos以及raft介绍&lt;/h1&gt;
&lt;p&gt;下面是关于两种一致性协议的相关论文的详细讲解，这里就不再赘述&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;PAXOS
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/6d01a8d2df9f&quot;&gt;《Paxos Made Simple》论文翻译&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/assets/pdf/paxos-simple1.pdf&quot;&gt;《Paxos Made Simple》原文&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;RAFT
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;http://www.infoq.com/cn/articles/raft-paper&quot;&gt;《In search of an Understandable Consensus Algorithm (Extended Version)》中文翻译&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;/assets/pdf/raft.pdf&quot;&gt;《In search of an Understandable Consensus Algorithm (Extended Version)》原文&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;http://thesecretlivesofdata.com/raft/&quot;&gt;Raft Understandable Distributed Consensus&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;https://github.com/coreos/etcd/tree/master/raft#usage&quot;&gt;raft implementation by Go&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-3-paxos以及raft异同这里的paxos指的是multi-paxos&quot;&gt;3 paxos以及raft异同（这里的paxos指的是Multi-Paxos）&lt;/h1&gt;

&lt;h2 id=&quot;heading-31-相同点&quot;&gt;3.1 相同点&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;保障一致性：一个日志一旦被提交(得到多数派的赞成），就不会丢失，也不可能更改&lt;/li&gt;
  &lt;li&gt;协议都使用一个唯一的整数作为标识符来标明leader的合法性，paxos叫做proposer-id，ZAB叫epoch，VR叫view，raft叫term。&lt;/li&gt;
  &lt;li&gt;在同一个时刻，都只会存在一个合法的leader&lt;/li&gt;
  &lt;li&gt;都是利用了同一个性质：两个多数派集合之间存在一个公共成员&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-32-差异点&quot;&gt;3.2 差异点&lt;/h2&gt;
&lt;p&gt;1.理论与实践&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;paxos是理论上的一致性协议，虽然高效但是难以理解，难以在实际环境中实现，而一些paxos实现的一致性系统最终也产生一些偏离；&lt;/li&gt;
  &lt;li&gt;raft相对来说更加易于理解，且能很好的运用到实际中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;2.特点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;paxos的特点在与从一个提案被提出到被接受分为两个阶段，第一个阶段去询问值，第二阶段根据询问的结果提出值。这两个阶段是无法分割的，两个阶段的每个细节都是精心设计的，相互关联，共同保障了协议的一致性&lt;/li&gt;
  &lt;li&gt;raft的特点在于使用算法分解，将协议分为领导选取、日志复制和安全性和减少状态（相对于Paxos，Raft 减少了非确定性的程度和服务器互相不一致的方式）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;3.领导人的定位&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;paxos一致性协议中，没有领导人也能很好的工作，领导人选举仅仅是性能优化的手段，而且不是一致性所必须要求&lt;/li&gt;
  &lt;li&gt;raft一致性协议中，使用领导人选举作为一致性协议里必不可少的部分，并且将尽可能多的功能集中到了领导人身上。这样就简化了对日志复制的管理，使得算法更加容易理解。另外Raft 尽可能的减少了非领导人的功能。例如，Raft 中日志条目都遵循着从领导人发送给其他人这一个方向：附加条目 RPC 是向外发送的。在 VR 中，日志条目的流动是双向的（领导人可以在选举过程中接收日志）；这就导致了额外的机制和复杂性。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4.领导选取&lt;br /&gt;
都是用心跳机制来保证追随者实时感应到当前领导人，心跳丢失则表明领导人宕机&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;paxos协议未给领导选取提出独立的选举方案，针对领导人选举的独立的机制可以是任意强一致算法，当然也可以是paxos&lt;/li&gt;
  &lt;li&gt;raft通过选举超时(随机超时避免重复瓜分选票)来随机选取领导人，一台服务器最多能给一个候选人投票，同时为了保证安全性，宕机后的重新选举需要选举有效的含有所有被提交日志条目的机器：只有追随者机器上的日志和候选人机器上的日志一样新，追随者才能给候选人投票。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;5.大多数一致性协议中仅使用leader主节点来集中处理事务请求&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;使用paxos实现的一致性集群中Hyperspace 只有一台leader对外提供服务，其他机器只做数据备份&lt;/li&gt;
  &lt;li&gt;raft随机挑选一个服务器进行通信。如果第一次挑选的服务器不是领导人，那么那个服务器会拒绝客户端的请求并且提供它最近接收到的领导人的信息&lt;/li&gt;
  &lt;li&gt;zk集群中其他follower能够接受客户端请求，但是仅仅只是接受，然后把请求转发给leader&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;6.提案提交&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;paxos从提案被提出到提交需要经过两个阶段，多个提案可以并发同时完成第一个初审阶段，然后串行的按序完成阶段二，两个阶段leader都需要与集群中大部分机器完成通信，且需要集群中过半机器审核通过&lt;/li&gt;
  &lt;li&gt;raft从提案被提出到提交，是提案对应的日志从leader复制到集群中剩余机器的过程(通过rpc)，当该日志复制到集群中的过半机器后，该提案才能被提交。提案的提交具有强顺序性(串行完成提交)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;7.日志条目&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;paxos有指令空缺，宕机后重新选举得到的领导人若在日志上有指令空缺，可通过二阶段提交从其它节点获取已经被提交的日志来填补指令空缺。&lt;/li&gt;
  &lt;li&gt;raft的日志条目具有强顺序性，强调日志的连续性，不允许出现空洞，领导人永远不会覆盖或者删除自己的日志，它只会增加条目，新选举出的Leader已经拥有全部的可以被提交的日志&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-4-混淆概念&quot;&gt;4 混淆概念&lt;/h1&gt;

&lt;p&gt;raft以及paxos协议中针对每个提案，都有一个全局唯一的递增id，用来表示某个提案的唯一性，这里的提案可以对应为客户端的一次请求或者一条指令。而paxos协议中，每个提案对应一个编号以及提案值，这里的编号与上述的提案id不同，该编号的概念存在于某个提案A从提出到被决策的生命周期中(在该生命中期中自增且唯一)，也可以理解为某个提案A被提出者提出的字数编号，例如序列为100的提案被第一次提出、被第二次提出。&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="consensus" /><summary type="html">1 一致性协议 一致性协议简单来说，是一种保障集群中所有机器上的数据达到一致的协议。最直观的最好理解的一致性协议，例如2PC、3PC，便是在做数据操作时，对集群中的所有机器同时做数据操作，仅当集群中的全部机器操作成功后，所有机器保证一致后，该数据操作才成功，否则只要有一台机器因为网络等其他原因导致数据操作失败，该数据操作就会失败，其他操作成功的机器也会全部进行数据回滚。 上述一致性协议虽然简单，但相对保守，且无法应对机器宕机、网络分区等故障问题。针对这种情况，paxos以及raft等一致性协议应运而生。 新一代的一致性协议有如下特点： 采取过半原则：即当集群中大于一半的机器认同该数据操作，且数据操作成功后，该数据操作被集群认可（因为任何两个多数派集合中至少有一个成员是公共的） 允许集群中出现部分机器不一致性，且时刻异步进行着机器之间数据的同步 选举出leader协助集群中机器间数据的同步 在出现机器宕机或者网络分区后，集群仍能正常工作，且保证集群一致性，同时当机器重启或者网络恢复后，也能保证集群一致性（利用持久化数据存储）</summary></entry><entry><title type="html">基于配置的流程管理框架</title><link href="http://localhost:4000/blog/2018/08/04/flow-framework/" rel="alternate" type="text/html" title="基于配置的流程管理框架" /><published>2018-08-04T00:00:00+08:00</published><updated>2018-08-04T00:00:00+08:00</updated><id>http://localhost:4000/blog/2018/08/04/flow-framework</id><content type="html" xml:base="http://localhost:4000/blog/2018/08/04/flow-framework/">&lt;h1 id=&quot;heading-1-介绍&quot;&gt;1 介绍&lt;/h1&gt;
&lt;p&gt;通用的流程编排框架，将整个流程以xml配置文件的形式管理起来：定义流程、管理上下文、控制流程的流转（按条件或者顺序），各个流程节点的执行（同步或者异步）。同时对每个流程节点进行监控以及统计，完成对流程的整体把控。&lt;/p&gt;

&lt;h1 id=&quot;heading-2-基本概念&quot;&gt;2 基本概念&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;flow:数据流程对象&lt;/li&gt;
  &lt;li&gt;step:流程的子步骤，也叫流程节点&lt;/li&gt;
  &lt;li&gt;action:流程中各个步骤执行的操作&lt;/li&gt;
  &lt;li&gt;subflow:子流程，一个流程节点可以执行操作；也可以执行某个子流程&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-3-用法&quot;&gt;3 用法&lt;/h1&gt;

&lt;h2 id=&quot;heading-31-定义流程的输入与输出&quot;&gt;3.1 定义流程的输入与输出&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;定义输入为Data&lt;/li&gt;
  &lt;li&gt;定义输出为Result&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-32-定义步骤子节点&quot;&gt;3.2 定义步骤（子节点）&lt;/h2&gt;

&lt;p&gt;所有的子节点需要实现接口org.cuner.flowframework.core.Action&amp;lt;Data, Result&amp;gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Action1 implements Action&amp;lt;Data, Result&amp;gt; {
    @Override
    public void execute(FlowContext&amp;lt;Data, Result&amp;gt; context) {
        if (context.getResult() == null) {
            context.setResult(new Result());
        }
        context.setParameter(&quot;param&quot;, 1);
        context.getResult().setResult(context.getData().getData());
        System.out.println(&quot;----------flow: &quot; +  context.getFlowName() + &quot; step: &quot; + context.getStepName() + &quot; action: &quot; + this.getClass().getSimpleName() + &quot;----------&quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;同时保证启动后，将所有action注入到spring容器中&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id=&quot;action1&quot; class=&quot;org.cuner.flowframework.test.action.Action1&quot;/&amp;gt;
&amp;lt;bean id=&quot;action2&quot; class=&quot;org.cuner.flowframework.test.action.Action2&quot;/&amp;gt;
&amp;lt;bean id=&quot;action3&quot; class=&quot;org.cuner.flowframework.test.action.Action3&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;heading-33-通过xml配置定义流程&quot;&gt;3.3 通过xml配置定义流程&lt;/h2&gt;

&lt;p&gt;详细的配置结构请查看xsd文件&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flows&lt;/code&gt;标签为root标签，可包含多个&lt;code class=&quot;highlighter-rouge&quot;&gt;flow&lt;/code&gt;标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flow&lt;/code&gt;标签标识一个流程，可以是一个主流程也可以是一个子流程，拥有name属性代表流程名称（流程名字要求全局唯一），可包含多个&lt;code class=&quot;highlighter-rouge&quot;&gt;step&lt;/code&gt;标签&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;step&lt;/code&gt;标签标识一个步骤（流程节点）
    &lt;ul&gt;
      &lt;li&gt;包含零或一个&lt;code class=&quot;highlighter-rouge&quot;&gt;condition类&lt;/code&gt;标签，标识该步骤的执行条件，若没有则默认执行&lt;/li&gt;
      &lt;li&gt;包含零或多个&lt;code class=&quot;highlighter-rouge&quot;&gt;conditionTransition&lt;/code&gt;标签，标识状态的流转，若没有则默认流转到配置文件中下一个步骤&lt;/li&gt;
      &lt;li&gt;name属性：标识步骤名称&lt;/li&gt;
      &lt;li&gt;asyn属性：标识是否异步执行&lt;/li&gt;
      &lt;li&gt;action属性：标识步骤执行的操作，关联Action接口某个实现类的bean id&lt;/li&gt;
      &lt;li&gt;subflow属性：标识步骤所代表的子流程（action属性和subflow属性只能存在一者）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;condition类标签&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;condition&lt;/code&gt;标签：
        &lt;ul&gt;
          &lt;li&gt;属性key：为输入对象Data的某个属性&lt;/li&gt;
          &lt;li&gt;value：与输入对象Data的某个属性值相比较的值&lt;/li&gt;
          &lt;li&gt;comparator：关系运算符（eq、ne、gt、lt、ge、le、ln）&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;expCondition&lt;/code&gt;标签，拥有express属性，值为判断条件的表达式，如 data == &quot;test&quot;，其中data为输入对象Data的一个属性&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;andCondtion&lt;/code&gt;标签，包含多个condition类标签，对多个condition的结果做与操作&lt;/li&gt;
      &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;orCondtion&lt;/code&gt;标签，包含多个condition类标签，对多个condition的结果做或操作&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;conditionTransition&lt;/code&gt;标签
    &lt;ul&gt;
      &lt;li&gt;包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;condition&lt;/code&gt;标签，判断是否符合状态流程的条件&lt;/li&gt;
      &lt;li&gt;包含一个to属性：标识状态流转的下一个节点&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;flows&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://repo.cuner.com/schema/flow&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;flow&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;mainFlow&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action1&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;asyn=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step3&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;subflow=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;subflow&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step4&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;subflow=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;subflow&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;asyn=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step5&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;condition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;comparator=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;eq&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/step&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step6&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;expCondition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'data.getData() == &quot;test&quot; '&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/step&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step7&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;andCondition&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;condition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;comparator=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;eq&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/andCondition&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/step&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step8&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;orderTransition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step9&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/step&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step9&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;conditionTransition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;to=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step10&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
                &lt;span class=&quot;nt&quot;&gt;&amp;lt;condition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;key=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;data&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;value=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;comparator=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;eq&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;/conditionTransition&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/step&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;step10&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action3&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&quot;nt&quot;&gt;&amp;lt;expCondition&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;expression=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'parameters.get(&quot;params&quot;) == 1'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;/step&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/flow&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;flow&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;subflow&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sub_step1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action1&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;asyn=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;nt&quot;&gt;&amp;lt;step&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;sub_step2&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;action=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;action2&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;/flow&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/flows&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;heading-34-流程注入&quot;&gt;3.4 流程注入&lt;/h2&gt;

&lt;p&gt;配置文件需要放在classpath下，案例中的配置文件就是在classpath下的flow.xml文件&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id=&quot;flowManager&quot; class=&quot;org.cuner.flowframework.core.manager.FlowManager&quot;&amp;gt;
    &amp;lt;property name=&quot;flowFiles&quot;&amp;gt;
        &amp;lt;list&amp;gt;
            &amp;lt;value&amp;gt;flow.xml&amp;lt;/value&amp;gt;
        &amp;lt;/list&amp;gt;
    &amp;lt;/property&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;heading-35-执行&quot;&gt;3.5 执行&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Result result = flowManager.execute(&quot;mainFlow&quot;, data);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;由于各个步骤可异步执行，在主流程的执行中加入了闭锁，只有当所有步骤（包括异步的）执行完成，execute方法才能正确返回。&lt;/p&gt;

&lt;h2 id=&quot;heading-36-查看日志&quot;&gt;3.6 查看日志&lt;/h2&gt;
&lt;p&gt;可查看流程执行的完整堆栈，可以在logback.xml中如下配置&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;logger name=&quot;flow-record&quot; level=&quot;info&quot; additivity=&quot;false&quot;&amp;gt;
    &amp;lt;appender-ref ref=&quot;FLOW_RECORD&quot;/&amp;gt;
&amp;lt;/logger&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述案例执行后日志如下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;21:03:23.431 [main] INFO  flow-record - 2018-08-04 21:03:23,415
[flow:mainFlow | start:2018-08-04 21:03:23,353 | end:2018-08-04 21:03:23,380 | cost:27]
|----[step:step1 | start:2018-08-04 21:03:23,354 | end:2018-08-04 21:03:23,355 | cost:1]
|----(step:step2 | start:2018-08-04 21:03:23,358 | end:2018-08-04 21:03:23,359 | cost:1) (asynchronously)
|----[step:step3 | start:2018-08-04 21:03:23,359 | end:2018-08-04 21:03:23,360 | cost:1]
        |----[sub_flow:subflow | start:2018-08-04 21:03:23,359 | end:2018-08-04 21:03:23,360 | cost:1]
                |----(step:sub_step1 | start:2018-08-04 21:03:23,360 | end:2018-08-04 21:03:23,360 | cost:0) (asynchronously)
                |----[step:sub_step2 | start:2018-08-04 21:03:23,360 | end:2018-08-04 21:03:23,360 | cost:0]
|----(step:step4 | start:2018-08-04 21:03:23,361 | end:2018-08-04 21:03:23,361 | cost:0) (asynchronously)
        |----[sub_flow:subflow | start:2018-08-04 21:03:23,361 | end:2018-08-04 21:03:23,361 | cost:0]
                |----[step:sub_step2 | start:2018-08-04 21:03:23,361 | end:2018-08-04 21:03:23,361 | cost:0]
                |----(step:sub_step1 | start:2018-08-04 21:03:23,361 | end:2018-08-04 21:03:23,361 | cost:0) (asynchronously)
|----[step:step5 | start:2018-08-04 21:03:23,378 | end:2018-08-04 21:03:23,380 | cost:2]
|----[step:step6 | start:2018-08-04 21:03:23,380 | end:2018-08-04 21:03:23,380 | cost:0]
|----[step:step7 | start:2018-08-04 21:03:23,380 | end:2018-08-04 21:03:23,380 | cost:0]
|----[step:step8 | start:2018-08-04 21:03:23,380 | end:2018-08-04 21:03:23,380 | cost:0]
|----[step:step9 | start:2018-08-04 21:03:23,380 | end:2018-08-04 21:03:23,380 | cost:0]
|----[step:step10 | start:2018-08-04 21:03:23,380 | end:2018-08-04 21:03:23,380 | cost:0]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;heading-4-源码&quot;&gt;4 源码&lt;/h1&gt;

&lt;p&gt;最后，附上代码:https://github.com/Cuner/flow-framework&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="flow" /><summary type="html">1 介绍 通用的流程编排框架，将整个流程以xml配置文件的形式管理起来：定义流程、管理上下文、控制流程的流转（按条件或者顺序），各个流程节点的执行（同步或者异步）。同时对每个流程节点进行监控以及统计，完成对流程的整体把控。</summary></entry><entry><title type="html">基于spring的groovy动态加载框架</title><link href="http://localhost:4000/blog/2018/06/26/groovy-loader/" rel="alternate" type="text/html" title="基于spring的groovy动态加载框架" /><published>2018-06-26T00:00:00+08:00</published><updated>2018-06-26T00:00:00+08:00</updated><id>http://localhost:4000/blog/2018/06/26/groovy-loader</id><content type="html" xml:base="http://localhost:4000/blog/2018/06/26/groovy-loader/">&lt;h1 id=&quot;heading-1-groovy-loader背景&quot;&gt;1 groovy loader背景&lt;/h1&gt;
&lt;p&gt;由于groovy动态语言的特性，使用方式与java一致，同时又特别适合与Spring的动态语言支持一起使用，所以基于java的groovy脚本的动态加载的使用场景还是比较多的&lt;/p&gt;

&lt;h1 id=&quot;heading-2-简介&quot;&gt;2 简介&lt;/h1&gt;
&lt;p&gt;动态加载指定目录下的groovy脚本，并将其注册为groovy bean，放置于ApplicationContext容器中，并使用命名空间进行分类区分(一个namespace对应于一个ApplicationContext)。同时能够动态感知到groovy脚本的新增、修改以及删除事件，并自动重新加载。&lt;/p&gt;

&lt;h1 id=&quot;heading-3-原理&quot;&gt;3 原理&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;使用spring配置文件来管理注册groovy bean：每一个spring配置文件作为一个ApplicationContext，管理一个namespace下的groovy bean&lt;/li&gt;
  &lt;li&gt;spring配置文件使用标签&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;lang:groovy&amp;gt;&lt;/code&gt;，通过指定script-source来加载指定路径下的groovy脚本，通过refresh-check-delay属性来定时动态加载每个groovy bean&lt;/li&gt;
  &lt;li&gt;通过扫描监听指定路径下spring配置文件的变更，来接受groovy脚本的新增、删除事件&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-31-监听器listener&quot;&gt;3.1 监听器listener&lt;/h2&gt;
&lt;p&gt;由于我们需要动态获取groovy脚本的变更，包含更新、新增、删除。接收到groovy脚本变更后需要触发用户自定义事件，所以我们先提供一个待用户实现的监听器接口，用于接受groovy变更事件，并执行相应代码&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GroovyRefreshedEvent&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class GroovyRefreshedEvent {

    private ApplicationContext ancestorContext;

    private Map&amp;lt;String, FileSystemXmlApplicationContext&amp;gt; namespacedContextMap;

    public GroovyRefreshedEvent(ApplicationContext ancestorContext, Map&amp;lt;String, FileSystemXmlApplicationContext&amp;gt; contextMap) {
        this.ancestorContext = ancestorContext;
        this.namespacedContextMap = contextMap;
    }
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上述提到过，指定目录下的groovy脚本会被注册为groovy bean，并使用Applocation容器进行管理，同时还引入了namespace的概念，每个namespace分别对应一个Application容器，允许namespace不同但是类名相关的groovy bean存在。于是监听器的Event对象被设计成包含一个父容器以及namespace为key，对应Applocation容易为value的Map。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GroovyRefreshedListener
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface GroovyRefreshedListener {

  void groovyRefreshed(GroovyRefreshedEvent event);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这个需要用户来实现&lt;/p&gt;

&lt;h2 id=&quot;heading-32-触发器trigger&quot;&gt;3.2 触发器trigger&lt;/h2&gt;
&lt;p&gt;由于需要动态去发现groovy脚本的变更，需要通过定时轮训使用触发器去判断groovy脚本是否完成了变更。上述提到过，框架通过&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;lang:Groovy&amp;gt;&lt;/code&gt;来定时加载groovy脚本，通过扫描监听指定路径下spring配置文件的变更。通过这样的方式来接受groovy脚本的新增、删除事件。同样触发器也允许用户自定义，框架提供了一个默认的触发器&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GroovyRefreshedListener
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface GroovyRefreshTrigger {

  boolean isTriggered(Map&amp;lt;String, Long&amp;gt; resourcesLastModifiedMap, String groovyResourcesDir);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;ResourceModifiedTrigger
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ResourceModifiedTrigger implements GroovyRefreshTrigger {
  public boolean isTriggered(Map&amp;lt;String, Long&amp;gt; resourcesLastModifiedMap, String groovyResourcesDir) {
      if (StringUtils.isBlank(groovyResourcesDir)) {
          groovyResourcesDir = this.getClass().getClassLoader().getResource(&quot;&quot;).getPath() + &quot;/spring/groovy&quot;;
      }
      File groovyFileDir = new File(groovyResourcesDir);
      List&amp;lt;File&amp;gt; groovyFileList = NamespacedGroovyLoader.getResourceListFromDir(groovyFileDir);
      for (File file : groovyFileList) {
          //新增
          if (!resourcesLastModifiedMap.containsKey(file.getName())) {
              return true;
          } else {
              //修改
              if (resourcesLastModifiedMap.get(file.getName()) != file.lastModified()) {
                  return true;
              }
          }
      }

      //删除
      if (resourcesLastModifiedMap.size() != groovyFileList.size()) {
          return true;
      }
      return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;默认的触发器就是通过spring配置文件上一次修改的时间，去判断文件是否被修改&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-33-groovy-loader&quot;&gt;3.3 groovy loader&lt;/h2&gt;
&lt;p&gt;初始化时会将指定目录下的groovy脚本动态加载成bean，并根据namespace注册到不同的Application容器中。注：以spring配置文件的名称作为namespace&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void initLoadResources() {
    if (MapUtils.isNotEmpty(this.namespacedContext)) {
        toDestoryContext = new ArrayList&amp;lt;FileSystemXmlApplicationContext&amp;gt;(this.namespacedContext.values());
    }
    this.namespacedContext = new HashMap&amp;lt;String, FileSystemXmlApplicationContext&amp;gt;();
    this.resourcesLastModifiedMap = new ConcurrentHashMap&amp;lt;String, Long&amp;gt;();
    //定位资源文件路径
    if (StringUtils.isBlank(groovyResourcesDir)) {
        groovyResourcesDir = this.getClass().getClassLoader().getResource(&quot;&quot;).getPath() + &quot;/spring/groovy&quot;;
    }
    File groovyFileDir = new File(groovyResourcesDir);
    List&amp;lt;File&amp;gt; groovyFileList = getResourceListFromDir(groovyFileDir);//获取指定目录下所有spring配置文件
    for (File file : groovyFileList) {
        FileSystemXmlApplicationContext context = new FileSystemXmlApplicationContext(new String[] {file.toURI().toString()}, true, parentContext);
        this.namespacedContext.put(file.getName().replace(&quot;xml&quot;, &quot;&quot;), context);
        this.resourcesLastModifiedMap.put(file.getName(), file.lastModified());
    }

    //触发监听器事件
    listener.groovyRefreshed(new GroovyRefreshedEvent(parentContext, this.namespacedContext));

    if (CollectionUtils.isNotEmpty(toDestoryContext)) {
        for (FileSystemXmlApplicationContext fileSystemXmlApplicationContext : toDestoryContext) {
            fileSystemXmlApplicationContext.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;heading-34-spring配置文件&quot;&gt;3.4 spring配置文件&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;beans&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:context=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/context&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xmlns:lang=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/lang&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;xmlns:xsi=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&lt;/span&gt;
       &lt;span class=&quot;na&quot;&gt;xsi:schemaLocation=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
    http://www.springframework.org/schema/lang http://www.springframework.org/schema/lang/spring-lang.xsd &quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;context:annotation-config&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

    &lt;span class=&quot;nt&quot;&gt;&amp;lt;lang:groovy&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;id=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;test&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;refresh-check-delay=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;2000&quot;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;proxy-target-class=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;true&quot;&lt;/span&gt;
                 &lt;span class=&quot;na&quot;&gt;script-source=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;classpath:groovy/one/Test.groovy&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;/&amp;gt;&lt;/span&gt;

&lt;span class=&quot;nt&quot;&gt;&amp;lt;/beans&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;heading-4-使用&quot;&gt;4 使用&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;bean id=&quot;listener&quot; class=&quot;org.cuner.groovy.loader.test.TestListener&quot;/&amp;gt;&amp;lt;!--需要实现org.cuner.groovy.loader.listener.GroovyRefreshedListener --&amp;gt;
&amp;lt;bean id=&quot;groovyLoader&quot; class=&quot;org.cuner.groovy.loader.NamespacedGroovyLoader&quot;&amp;gt;
    &amp;lt;property name=&quot;groovyResourcesDir&quot; value=&quot;&quot;/&amp;gt;&amp;lt;!--指定spring groovy配置文件目录，若不设置或者为空则默认为classpath下/spring/groovy目录--&amp;gt;
    &amp;lt;property name=&quot;listener&quot; ref=&quot;listener&quot;/&amp;gt;
    &amp;lt;property name=&quot;trigger&quot; ref=&quot;trigger&quot;/&amp;gt;
&amp;lt;/bean&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;heading-5-源码demo&quot;&gt;5 源码&amp;amp;Demo&lt;/h1&gt;
&lt;p&gt;代码托管在Github上，并附有使用demo，欢迎下载运行: https://github.com/Cuner/groovy-loader&lt;/p&gt;

&lt;h1 id=&quot;heading-6-版本升级-groovy-loader-v2&quot;&gt;6 版本升级 groovy-loader-v2&lt;/h1&gt;
&lt;p&gt;v1版本存在的缺陷在于：由于使用了&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;lang:groovy&amp;gt;&lt;/code&gt;标签，spring定时去重加载groovy bean，即使这个bean没有被修改，由此会产生一些性能消耗问题。为了解决这点，v2实现了groovy脚本的加载以及groovy bean的注入。同时由定时扫描spring配置改为扫描目录下的所有groovy脚本来实现触发器。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;GroovyScriptsModifiedTrigger
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isTriggered(Map&amp;lt;String, Long&amp;gt; lastScriptsModified, String baseDir) {
  if (StringUtils.isBlank(baseDir)) {
      baseDir = this.getClass().getClassLoader().getResource(&quot;&quot;).getPath() + &quot;/groovy&quot;;
  }

  List&amp;lt;File&amp;gt; fileList = getFileList(new File(baseDir));
  for (File file : fileList) {
      if (lastScriptsModified.get(file.getPath()) == null) {
          return true;
      }
      if (file.lastModified() != lastScriptsModified.get(file.getPath())) {
          return true;
      }
  }

  if (fileList.size() != lastScriptsModified.size()) {
      return true;
  }

  return false;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;p&gt;具体实现基本一致，区别在于外部传参baseDir由spring配置文件路径改为groovy脚本根目录路径。接下来我们看看是如何实现groovy脚本的加载以及groovy bean的注入。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;NamespacedGroovyLoader&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * 递归查找并加载namespace下的所有groovy文件
 * @param file
 * @param namespace
 */
private void scanGroovyFiles(File file, String namespace) throws Exception {
    if (!file.exists()) {
        return;
    }

    if (file.isFile() &amp;amp;&amp;amp; file.getName().endsWith(&quot;.groovy&quot;)) {
        ApplicationContext context = getOrCreateContext(namespace);
        DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) context.getAutowireCapableBeanFactory();

        String scriptLocation = file.toURI().toString();
        if (scriptNotExists(context, scriptLocation)) {
            throw new IllegalArgumentException(&quot;script not exists : &quot; + scriptLocation);
        }
        scriptLastModifiedMap.put(file.getPath(), file.lastModified());

        String className = StringUtils.removeEnd(scriptLocation.substring(scriptLocation.indexOf(baseDir) + baseDir.length() + 1).replace(&quot;/&quot;, &quot;.&quot;), &quot;.groovy&quot;);
        // 只有GroovyBean声明的类才实例化
        DSLScriptSource scriptSource = new DSLScriptSource(new ResourceScriptSource(context.getResource(scriptLocation)), className);

        Class scriptClass = groovyClassLoader.parseClass(scriptSource.getScriptAsString(), scriptSource.suggestedClassName());

        // Tell Groovy we don't need any meta
        // information about these classes
        GroovySystem.getMetaClassRegistry().removeMetaClass(scriptClass);
        groovyClassLoader.clearCache();

        // Create script factory bean definition.
        GroovyScriptFactory groovyScriptFactory = new GroovyScriptFactory(scriptLocation);
        groovyScriptFactory.setBeanFactory(beanFactory);
        groovyScriptFactory.setBeanClassLoader(urlClassLoader);
        Object bean = groovyScriptFactory.getScriptedObject(scriptSource);
        if (bean == null) {
            //只有静态方法的groovy脚本(没有类声明)
            return;
        }

        // Tell Groovy we don't need any meta
        // information about these classes
        GroovySystem.getMetaClassRegistry().removeMetaClass(bean.getClass());
        groovyScriptFactory.getGroovyClassLoader().clearCache();

        String beanName = StringUtils.removeEnd(file.getName(), &quot;.groovy&quot;).toLowerCase();
        if (beanFactory.containsBean(beanName)) {
            beanFactory.destroySingleton(beanName); //移除单例bean
            removeInjectCache(context, bean); //移除注入缓存 否则Caused by: java.lang.IllegalArgumentException: object is not an instance of declaring class
        }
        beanFactory.registerSingleton(beanName, bean); //注册单例bean
        beanFactory.autowireBean(bean); //自动注入

    } else if (file.isDirectory()) {
        File[] subFiles = file.listFiles();
        for (File subFile : subFiles) {
            scanGroovyFiles(subFile, namespace);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;groovy文件夹下第一级文件夹名称拼接namespacePrefix作为namespace，每个namespace分配一个ApplicationContext容器，每个namespace对应的bean都由各自的beanfactory加载注入，避免同名类加载导致的错误。同时groovy脚本更新后产生新的groovy bean之后，还需要移除之前的groovy bean，值得额外注意的是需要移除注入缓存，否则会报错：Caused by: java.lang.IllegalArgumentException: object is not an instance of declaring class
注意：由于我们不需要groovy的metaclass信息，这里对metaClass进行清除来进行优化&lt;/p&gt;

&lt;p&gt;最后，附上代码:https://github.com/Cuner/groovy-loader-v2&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="groovy" /><summary type="html">1 groovy loader背景 由于groovy动态语言的特性，使用方式与java一致，同时又特别适合与Spring的动态语言支持一起使用，所以基于java的groovy脚本的动态加载的使用场景还是比较多的</summary></entry><entry><title type="html">基于redis的分布式延时队列</title><link href="http://localhost:4000/blog/2018/05/30/delay-queue/" rel="alternate" type="text/html" title="基于redis的分布式延时队列" /><published>2018-05-30T00:00:00+08:00</published><updated>2018-05-30T00:00:00+08:00</updated><id>http://localhost:4000/blog/2018/05/30/delay-queue</id><content type="html" xml:base="http://localhost:4000/blog/2018/05/30/delay-queue/">&lt;p&gt;延时队列的使用场景非常多，目前集中式场景可以使用JDK自带的delayQueue，本文使用redis队列来实现两种分布式的延时队列，并进行了对比分析&lt;/p&gt;

&lt;h1 id=&quot;heading-1-封装统一的队列消息结构&quot;&gt;1 封装统一的队列消息结构&lt;/h1&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class DelayMessage {

    /**
     * 正执行消息的token
     */
    private String tmpKey;

    /**
     * 消息内容
     */
    private String message;

    /**
     * 延迟时间 纳秒
     */
    private long delay;

    /**
     * 到期时间 纳秒
     */
    private long expire;

    /**
     * 创建时间 纳秒
     */
    private long registerTime;
    
    ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;heading-2-同步延时队列&quot;&gt;2 同步延时队列&lt;/h1&gt;
&lt;p&gt;原理：通过LRANG获取队列头部元素，从而获得到期时间，当数据达到到期时间后，通过LPOP取出数据。并发情况下会加分布式锁，同一时刻只能有一个线程访问队列并阻塞等待数据准备完成(达到延时时间)。当线程获取到可以返回的数据后，才能释放锁。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public DelayMessage pop() {
    while (true) {
        Long waitTime = null;
        Jedis jedis = jedisPool.getResource();
        try {
            if (this.syn) {
                lock.lock(this.queueName);
            }
            //获取头部的数据
            List&amp;lt;String&amp;gt; dataList = jedis.lrange(this.queueName, 0L, 0L);
            if (CollectionUtils.isNotEmpty(dataList)) {
                String data = dataList.get(0);
                DelayMessage message = gson.fromJson(data, DelayMessage.class);
                if (message != null) {
                    long now = System.nanoTime();
                    if (message.getExpire() &amp;gt; now) {
                        //没有到期
                        waitTime = message.getExpire() - now;
                    } else {
                        jedis.lpop(this.queueName);
                        return message;
                    }
                }
            }

            if (waitTime != null) {
                try {
                    Thread.sleep(waitTime / 1000);
                } catch (InterruptedException e) {
                    //do nothing
                }
            }

        } finally {
            if (this.syn) {
                lock.unlock(this.queueName);
            }
            jedis.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;基于redis，&lt;strong&gt;并发情况下会加分布式锁&lt;/strong&gt;，单线程场景（syn=false）性能较好， 并发场景性能较差&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;若在并发场景下，设置syn=false，会导致消息重复消费、消息丢失的情况&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;支持delay时间的动态调整&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-3-并发延时队列&quot;&gt;3 并发延时队列&lt;/h1&gt;
&lt;p&gt;原理：直接通过LPOP取出数据，当数据达到到期时间后立即返回，若未达到到期时间，线程sleep至到期时间后将数据返回。这样就允许队列在无分布式锁的情况下并行消费。
存在的问题：从数据LPOP移除队列到数据返回之间有一段时间间隔，如果系统在这段时间出现异常，比如宕机、重启等等，就会出现数据丢失的情况。为了避免此种情况，引入了ack的方式，在通过LPOP去除数据后，随机将数据存储到另外一个临时redis set中，在用户接受到消息并处理完成后手动执行ack方法后才将数据从临时set中移除。而在机器重启时，再将改临时set里面的数据重新put到延时队列中。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public DelayMessage pop() {
    while (true) {
        Long waitTime;
        Jedis jedis = jedisPool.getResource();
        try {
            // 取队列头部的消息
            String result = jedis.lpop(queueName);
            // 队列非空
            if (result != null) {
                //暂存此条消息，放入执行集合
                String tmpKey = null;
                if (!autoAck) {
                    tmpKey = this.setExeMsg(result);//解决宕机数据丢失
                }
                DelayMessage delayMessage = gson.fromJson(result, DelayMessage.class);
                if (delayMessage != null) {
                    if (delayMessage.getExpire() &amp;gt; System.nanoTime()) {
                        // 消息未到可执行状态,休眠等待
                        waitTime = delayMessage.getExpire() - System.nanoTime();
                        try {
                            Thread.sleep(waitTime);
                        } catch (InterruptedException e) {
                            // do nothing
                        }
                    }
                    delayMessage.setTmpKey(tmpKey);
                    return delayMessage;
                }
            }
        } finally {
            jedis.close();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;基于redis，支持在&lt;strong&gt;无分布式锁&lt;/strong&gt;的情况下进行并发消费&lt;/li&gt;
  &lt;li&gt;autoAck为true时，吞吐量性能极好，autoAck为false，吞吐量会稍有下降&lt;/li&gt;
  &lt;li&gt;支持delay时间的动态调整&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;autoAck为false时，必须在处理完消息后手动调用ack方法，否则会导致应用重启后重新开始消费&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;heading-4-性能对比&quot;&gt;4 性能对比&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;RedisConcurrentDelayQueue和RedisSynDelayQueue的简单对比，数据是线下单机环境测试数据&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;队列种类&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;消费线程数&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;syn&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;autoAck&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;耗时&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;消息丢失&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;重复消费&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisConcurrentDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;false&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;53936ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisConcurrentDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;true&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;13130ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;消费进程关闭，正在处理的消息会丢失&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisSynDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;true&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;55420ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisSynDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;false&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;20012ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisConcurrentDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;false&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;7279ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisConcurrentDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;true&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1181ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;消费进程关闭，正在处理的消息会丢失&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisSynDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;true&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;61532ms&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;无&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RedisSynDelayQueue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;10&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;false&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;-&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;大量消息丢失&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;大量重复消费&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ol&gt;
  &lt;li&gt;若能接受系统重启、关闭时的少量消息丢失，推荐RedisConcurrentDelayQueue，并设置autoAck为true：性能最好，且消费线程越多，消费速度（吞吐量）也会相对越好&lt;/li&gt;
  &lt;li&gt;若不能接受消息丢失，在单机、单线程消费的场景下，可以选择RedisConcurrentDelayQueue（autoAck设置为false）RedisSynDelayQueue（syn设置为false）；&lt;/li&gt;
  &lt;li&gt;若不能接受消息丢失，且需要在多线程、分布式场景下消费，推荐推荐RedisConcurrentDelayQueue（autoAck设置为false），消费线程越多，消费速度（吞吐量）也会相对越好；&lt;/li&gt;
  &lt;li&gt;RedisSynDelayQueue在并发消费的场景下性能较差，不推荐使用。&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;heading-5-项目代码&quot;&gt;5 项目代码&lt;/h1&gt;
&lt;p&gt;代码托管在Github上，并附有使用demo，欢迎下载运行: https://github.com/Cuner/delay-queue&lt;/p&gt;

&lt;h1 id=&quot;heading-6-切换思路&quot;&gt;6 切换思路&lt;/h1&gt;
&lt;p&gt;当有延时任务或者延时消息产生时，暂时将延时任务/消息存放至某个容器里面(可以是数据记录的方式存储在db，也可以存储在redis zset中等等)，然后采用定时器不断去轮训容器里面的各个延时任务/消息，当扫描获取到达到过期时间的延时任务/消息后，将其推送到消息队列中以供消费，推送成功后再将其从容器里移除。
值得注意的是，同一个达到到期时间的延时任务/消息，可能会被连续的两次扫描命中（延时任务/消息从容器移除有延时），最后导致消息重复消费。&lt;/p&gt;

&lt;p&gt;参考：&lt;a href=&quot;https://tech.youzan.com/queuing_delay/&quot;&gt;有赞延迟队列设计&lt;/a&gt;&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Cuner&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="queue" /><summary type="html">延时队列的使用场景非常多，目前集中式场景可以使用JDK自带的delayQueue，本文使用redis队列来实现两种分布式的延时队列，并进行了对比分析</summary></entry></feed>