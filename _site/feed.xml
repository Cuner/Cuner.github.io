<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.5.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2018-02-11T15:50:00+08:00</updated><id>http://localhost:4000/</id><title type="html">Tobi7</title><subtitle>Tobi7's blog</subtitle><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Tobi7&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><entry><title type="html">Spring AOP代理</title><link href="http://localhost:4000/blog/2017/06/29/spring-aop-proxy/" rel="alternate" type="text/html" title="Spring AOP代理" /><published>2017-06-29T00:00:00+08:00</published><updated>2017-06-29T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/06/29/spring-aop-proxy</id><content type="html" xml:base="http://localhost:4000/blog/2017/06/29/spring-aop-proxy/">&lt;h2 id=&quot;heading-一spring-aop代理的相关属性&quot;&gt;一、Spring AOP代理的相关属性&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;开启AOP自动代理&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;aop:aspect-autoproxy /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;proxy-target-class:强调spring应该使用那种代理方式：JDK动态代理和CGLIB
    &lt;ul&gt;
      &lt;li&gt;JDK动态代理：代理对象必须为某个接口的实现，它是通过在运行期间创建一个接口的实现类来完成对目标对象的代理【默认属性值为false，即使用的是JDK动态代理】&lt;/li&gt;
      &lt;li&gt;CGLIB代理：原理类似于JDK代理，不同之处在于运行期间生成的代理对象是针对目标类扩展的子类，CGLIB是高效代码生成包，底层是依靠ASM（字节码编辑类库）操作字节码实现的，性能比JDK强。&lt;/li&gt;
      &lt;li&gt;使用CGLIB代理会出现的问题:无法通知Final方法，因为他们不允许被覆盖；还需要将CGLIB二进制包放入classpath下面；强制使用CGLIB代理需要将proxy-target-class设置为true&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;expose-proxy:目标对象内部的自我调用将无法实施切面中的增强&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-二aop代理无法切入同类调用方法的问题&quot;&gt;二、AOP代理无法切入同类调用方法的问题&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Service
public class Service {  
  
    //这个方法调用被切的方法,在外部被调用 
    public void callMethodA() {  
        ......  
        callMethodB();  
        ......  
    }  
      
    //Aop切入的方法 
    public void callMethodB() {  
        ......  
    }  
} 

@Aspect
@Service
public class Aspect {
    @After(&quot;execution(* Service.callMethodB(..))&quot;)  
    public void after() {  
        Logger.info(&quot;after call and do something.&quot;);
    }  
}  

//调用方式
service.callMethodA();

//spring配置
&amp;lt;aop:aspect-autoproxy proxy-target-class=&quot;true&quot;/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述的调用方式是根本无法进去切面的，在callMethodA()方法中调用callMethodB()相当于调用this.callMethodB()，此处的this指向目标对象，并不是调用代理对象的callMethodB()方法，解决方式如下两点&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;强制使用AOP代理&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//spring配置
&amp;lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot; expose-proxy=&quot;true&quot; /&amp;gt;

//调用callMethodB()
((Service)AopContext.currentProxy()).callMethodB();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;通过spring上下文获取代理类&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//spring配置
&amp;lt;aop:aspectj-autoproxy proxy-target-class=&quot;true&quot;/&amp;gt;

//调用callMethodB()
applicationContext.getBean(&quot;service&quot;).callMethodB();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;PS:使用第一种方式的时候要注意获取代理对象时的强制转换:使用默认的JDK动态代理的方式需要转换为接口，使用CGLIB代理的方式可以直接使用实现类的类型；同时代理对象使用的方法需要是public修饰的方法；spring自带的@transactional注解在使用中也有上述问题，该注解默认使用CGLIB代理。&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Tobi7&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="aop" /><summary type="html">一、Spring AOP代理的相关属性</summary></entry><entry><title type="html">数据库主从复制</title><link href="http://localhost:4000/blog/2017/05/15/database-master-slave-syn/" rel="alternate" type="text/html" title="数据库主从复制" /><published>2017-05-15T00:00:00+08:00</published><updated>2017-05-15T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/05/15/database-master-slave-syn</id><content type="html" xml:base="http://localhost:4000/blog/2017/05/15/database-master-slave-syn/">&lt;p&gt;复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。&lt;/p&gt;

&lt;h2 id=&quot;heading-一异步复制&quot;&gt;一、异步复制&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;MySQL的异步复制是MySQL自带的数据同步功能，在公司里面也是也就最为常见的。&lt;/li&gt;
  &lt;li&gt;Master服务器中需要开启二进制日志 binlog ，从服务器需要开启中继日志 relay-log 。&lt;/li&gt;
  &lt;li&gt;二进制日志binlog的主要功能是：记录数据库的变更内容；二进制日志在备份还原的时候至关重要。&lt;/li&gt;
  &lt;li&gt;中继日志relay-log则是从服务器中开启，作用是从主服务器的二进制日志中复制，并在在从服务器本地执行一次，达到与主服务器内容一致的效果。&lt;/li&gt;
  &lt;li&gt;一般MySQL复制是放在内网中进行的，因为MySQL的同步并没有进行加密。而且相比较于在公网传输，在内网中丢包的概率较低，带宽也高。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;复制过程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;该过程的第一部分就是master记录二进制日志。在每个事务更新数据完成之前，master在二进制日志中记录这些改变。MySQL将事务串行的写入二进制日志，即使事务中的语句都是交叉执行的。在事件写入二进制日志完成后，master通知存储引擎提交事务。&lt;/li&gt;
  &lt;li&gt;下一步就是slave将master的binary log拷贝到它自己的中继日志。首先，slave开始一个工作线程——I/O线程。I/O线程在master上打开一个普通的连接，然后开始binlog dump process（根据从服务器在日志中读取的最后一次成功更新的位置）。Binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件。I/O线程将这些事件写入中继日志。&lt;/li&gt;
  &lt;li&gt;SQL slave thread（SQL从线程）处理该过程的最后一步。SQL线程从中继日志读取事件，并重放其中的事件而更新slave的数据，使其与master中的数据一致。只要该线程与I/O线程保持一致，中继日志通常会位于OS的缓存中，所以中继日志的开销很小。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此外，在master中也有一个工作线程（I/O线程）：和其它MySQL的连接一样，slave在master中打开一个连接也会使得master开始一个线程。复制过程有一个很重要的限制——复制在slave上是串行化的，也就是说master上的并行更新操作不能在slave上并行操作。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/post/2017-05-15-database-master-slave-sync/master-slave-sync.png&quot; alt=&quot;master-slave-sync.png&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;heading-二半同步复制&quot;&gt;二、半同步复制&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;与传统的异步复制相比，半同步复制在多个Slave节点中会选取一个节点进行半同步复制。也就是说，当Master提交一个事务的时候，在这个半同步复制的Slave端返回一个同步完成的Ack包之后，服务器才会向用户返回事务提交成功，而其他的节点则是采用传统的异步复制方式进行同步。&lt;/li&gt;
  &lt;li&gt;半同步是复制是基于异步复制之上进行的，也就是说配置半同步复制之前需要先配置到异步复制。&lt;/li&gt;
  &lt;li&gt;半同步复制可以保证在主节点发生故障的时候，总有一个节点的数据与主节点一样。这样在进行切换的时候，可以更加快速地把这个Slave节点设置成主节点来使用。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-三binlog-格式&quot;&gt;三、binlog 格式&lt;/h2&gt;

&lt;h3 id=&quot;heading-statement每一条会修改数据的sql都会记录在binlog中&quot;&gt;statement:每一条会修改数据的sql都会记录在binlog中&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点：不需要记录每一行的变化，减少了binlog日志量，节约了IO，提高性能。(相比row能节约多少性能与日志量，这个取决于应用的SQL情况，正常同一条记录修改或者插入row格式所产生的日志量还小于Statement产生的日志量，但是考虑到如果带条件的update操作，以及整表删除，alter表等操作，ROW格式会产生大量日志，因此在考虑是否使用ROW格式日志时应该跟据应用的实际情况，其所产生的日志量会增加多少，以及带来的IO性能问题。)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点：由于记录的只是执行语句，为了这些语句能在slave上正确运行，因此还必须记录每条语句在执行的时候的一些相关信息(时间等)，以保证所有语句能在slave得到和在master端执行时候相同的结果。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heading-row不记录sql语句上下文相关信息仅保存哪条记录被修改&quot;&gt;Row:不记录sql语句上下文相关信息，仅保存哪条记录被修改&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;优点：binlog中可以不记录执行的sql语句的上下文相关的信息，仅需要记录那一条记录被修改成什么了。所以rowlevel的日志内容会非常清楚的记录下每一行数据修改的细节。而且不会出现某些特定情况下的存储过程，或function，以及trigger的调用和触发无法被正确复制的问题&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缺点：所有的执行的语句当记录到日志中的时候，都将以每行记录的修改来记录，这样可能会产生大量的日志内容,比如一条update语句，修改多条记录，则binlog中每一条修改都会有记录，这样造成binlog日志量会很大，特别是当执行alter table之类的语句的时候，由于表结构修改，每条记录都发生改变，那么该表每一条记录都会记录到日志中。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heading-mixedlevel-是以上两种level的混合使用&quot;&gt;Mixedlevel: 是以上两种level的混合使用。&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;一般的语句修改使用statment格式保存binlog，如一些函数，statement无法完成主从复制的操作，则采用row格式保存binlog,MySQL会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种.新版本的MySQL中队row level模式也被做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录。至于update或者delete等修改数据的语句，还是会记录所有行的变更。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;注：所以当数据库在采取异步复制的同步策略时，如果当binlog的格式是Row的情况下存在【在主库更新十条记录之后，从库只更新了5条】的情况&lt;/p&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Tobi7&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="mysql" /><summary type="html">复制过程中一个服务器充当主服务器，而一个或多个其它服务器充当从服务器。</summary></entry><entry><title type="html">数据库锁机制</title><link href="http://localhost:4000/blog/2017/03/29/database-lock-mechanism/" rel="alternate" type="text/html" title="数据库锁机制" /><published>2017-03-29T00:00:00+08:00</published><updated>2017-03-29T00:00:00+08:00</updated><id>http://localhost:4000/blog/2017/03/29/database-lock-mechanism</id><content type="html" xml:base="http://localhost:4000/blog/2017/03/29/database-lock-mechanism/">&lt;h1 id=&quot;heading-数据库锁机制&quot;&gt;数据库锁机制&lt;/h1&gt;

&lt;h2 id=&quot;heading-为什么需要锁&quot;&gt;为什么需要锁&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;死锁问题&lt;/li&gt;
  &lt;li&gt;并发问题导致的不正确数据的读取和存储，破坏数据一致性
    &lt;ol&gt;
      &lt;li&gt;丢失更新：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题－－最后的更新覆盖了由其他事务所做的更新。例如，两个编辑人员制作了同一文档的电子副本。每个编辑人员独立地更改其副本，然后保存更改后的副本，这样就覆盖了原始文档。最后保存其更改副本的编辑人员覆盖另一个编辑人员所做的更改。如果在一个编辑人员完成并提交事务之前，另一个编辑人员不能访问同一文件，则可避免此问题&lt;/li&gt;
      &lt;li&gt;脏读：一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数据就处于不一致状态；这时，另一个事务也来读取同一条记录，如果不加控制，第二个事务读取了这些“脏”数据，并据此做进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象地叫做&quot;脏读&quot;。&lt;/li&gt;
      &lt;li&gt;不可重复读：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。&lt;/li&gt;
      &lt;li&gt;幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-锁的分类&quot;&gt;锁的分类&lt;/h2&gt;

&lt;h3 id=&quot;heading-数据库维度&quot;&gt;数据库维度&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;共享锁:&lt;br /&gt;
用于不更改或不更新数据的操作（只读操作）。共享锁允许并发事务读取同一个资源，数据资源上存在共享锁时，任何其他事务不允许修改数据&lt;/li&gt;
  &lt;li&gt;排它锁:&lt;br /&gt;
用于数据修改，确保不会同时多重更新同一数据。资源上存在排他锁时，其他任何事务不允许给资源上锁，当资源上有其他锁时，也无法对其加上排它锁&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;PS：只有共享锁与共享锁相互兼容，共享锁与排它锁、排它锁之间都互不兼容&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;意向锁&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;更新锁&lt;/p&gt;
    &lt;ol&gt;
      &lt;li&gt;用于可更新的资源中，防止多个会话在读取、锁定以及随后可能进行的资源更新时发生的死锁问题。&lt;/li&gt;
      &lt;li&gt;通常形式的死锁：一般一个更新模式由一个事务组成，此事务读取记录，获取资源的共享锁，然后修改行，此操作要求锁转换为排它锁。如果两个事务同时获得了资源上的共享锁，然后试图同时更新数据，则一个事务尝试将锁转换为排它锁。由于一个事务的排它锁与另一事务的共享锁的不兼容，从共享锁到排它锁的转换必须要等待一段时间，发送锁等待。而第二个事务同时也试图获取排它锁进行更新。由于两个事务都要转化为排它锁，并且每个事务都要等待另一个事务释放掉共享锁，因此发生死锁&lt;/li&gt;
      &lt;li&gt;更新锁一次只有一个事务可以获取资源的更新锁。如果事务修改资源，那么更新锁转化为排它锁，否则转化为共享锁。当资源上存在更新锁时，允许资源被读取（即更新锁与共享锁兼容），但不允许资源被修改&lt;/li&gt;
      &lt;li&gt;一般来说，在执行UPDATE操作时，SQL SERVER会使用到更新锁而不是依次加上共享锁和排它锁，已经回避了这种通常形式的死锁，更新锁与意向锁相互兼容&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heading-锁机制&quot;&gt;锁机制&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;DBMS&lt;/th&gt;
      &lt;th&gt;SELECT&lt;/th&gt;
      &lt;th&gt;UPDATE&lt;/th&gt;
      &lt;th&gt;INSERT&lt;/th&gt;
      &lt;th&gt;DELETE&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;MySQL(InnoDB)&lt;/td&gt;
      &lt;td&gt;不加锁&lt;/td&gt;
      &lt;td&gt;排它锁&lt;/td&gt;
      &lt;td&gt;排它锁&lt;/td&gt;
      &lt;td&gt;排它锁&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;SQL SERVER&lt;/td&gt;
      &lt;td&gt;共享锁&lt;/td&gt;
      &lt;td&gt;更新锁&lt;/td&gt;
      &lt;td&gt;排它锁&lt;/td&gt;
      &lt;td&gt;排它锁&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这两种锁机制的区别在于MySQL的查询与更新操作互相不阻塞；而SQL SERVER的更新锁转化成排它锁之前，其查询与更新操作互相不阻塞，当更新锁要转化为排它锁时，需要等待共享锁的释放，当更新锁转化为排它锁后，查询数据需要等待排它锁的释放。&lt;/p&gt;

&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;http://blog.csdn.net/samjustin1/article/details/52210125&quot;&gt;数据库锁机制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.chinaunix.net/uid-24111901-id-2627857.html&quot;&gt;InnoDB锁机制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://blog.itpub.net/13651903/viewspace-1091664/&quot;&gt;SQL SERVER锁机制&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;heading-程序员思想维度&quot;&gt;程序员思想维度&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;悲观锁
    &lt;ol&gt;
      &lt;li&gt;悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）是一种并发控制的方法。它可以阻止一个事务以影响其他用户的方式来修改数据。如果一个事务执行的操作都某行数据应用了锁，那只有当这个事务把锁释放，其他事务才能够执行与该锁冲突的操作。悲观锁的实现，往往依靠数据库提供的锁机制。悲观并发控制主要用于数据争用激烈的环境，以及发生并发冲突时使用锁保护数据的成本要低于回滚事务的成本的环境中。&lt;/li&gt;
      &lt;li&gt;悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;乐观锁
    &lt;ol&gt;
      &lt;li&gt;乐观并发控制（又名“乐观锁”，Optimistic Concurrency Control，缩写“OCC”）是一种并发控制的方法。它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。&lt;/li&gt;
      &lt;li&gt;乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会主动产生任何锁和死锁。但是在并发量高的情况下，可能导致某次数据修改多次重试，影响单次成功操作的时间。&lt;/li&gt;
      &lt;li&gt;数据版本实现乐观锁：实现数据版本有两种方式，第一种是使用版本号，第二种是使用时间戳。使用版本号时，可以在数据初始化时指定一个版本号，每次对数据的更新操作都对版本号执行+1操作。并判断当前版本号是不是该数据的最新的版本号。
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update table 
set date=1,version=version+1
where id=#{id} and version=#{version};
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;http://www.open-open.com/lib/view/open1452046967245.html&quot;&gt;乐观锁与悲观锁&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;heading-乐观锁另一种实现方式cas&quot;&gt;乐观锁另一种实现方式CAS&lt;/h2&gt;

&lt;p&gt;CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。&lt;/p&gt;

&lt;p&gt;CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值。否则，处理器不做任何操作。无论哪种情况，它都会在 CAS 指令之前返回该位置的值。CAS 有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。”这其实和乐观锁的冲突检查+数据更新的原理是一样的。&lt;/p&gt;

&lt;p&gt;java.util.concurrent(J.U.C)就是建立在CAS之上的。相对于对于synchronized这种阻塞算法，CAS是非阻塞算法的一种常见实现。所以J.U.C在性能上有了很大的提升。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class AtomicInteger extends Number implements java.io.Serializable {
    private volatile int value;  
 
    public final int get() {  
        return value;  
    }  
 
    public final int getAndIncrement() {  
        for (;;) {  
            int current = get();  
            int next = current + 1;  
            if (compareAndSet(current, next))  
                return current;  
        }  
    }  
 
    public final boolean compareAndSet(int expect, int update) {  
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);  
    }  
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参考：&lt;br /&gt;
&lt;a href=&quot;http://www.importnew.com/20472.html&quot;&gt;乐观锁的一种实现方式—CAS&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;heading-案例1初审统计数据迁移&quot;&gt;案例1：初审统计数据迁移&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;迁移背景&lt;br /&gt;
原有的统计方式采用的是实时count的方法获取统计数据，造成的问题是查询慢且无法获取长时间段的统计数据（sql超时）、无法获取某日统计数据的快照（前一天的待审核数据会变成今天的审核通过数据）&lt;/li&gt;
  &lt;li&gt;采用迁移方式&lt;br /&gt;
使用raptor迁移平台，扫描审核记录表，取出累计统计数据后进行加1操作，然后更新到统计表中。由于平台特性，数据迁移过程具有高并发性，由于强行采用先读取后更新的方式，会造成丢失更新的情况，于是这里考虑采用CAS&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;step 1:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;select id,passCount,rejectCount,hideCount,warnCount,waitCount 
from book.TradeItemAuditCount 
where type = #{type} and date = #{date} and editor = #{editor} 
and isDeleted = 0 limit 1

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;step 2:【失败重试】&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update book.TradeItemAuditCount 
set passCount = #{passCount} , rejectCount = #{rejectCount} , hideCount = #{hideCount} , warnCount = #{warnCount} , waitCount = #{waitCount} , updated = #{updated}
where id = #{id} and passCount = #{oldPassCount} and rejectCount = #{oldRejectCount} and hideCount = #{oldHideCount} and warnCount = #{oldWarnCount} and waitCount = #{oldWaitCount}
and isDeleted = 0 limit 1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;处理结果&lt;br /&gt;
一共扫描审核结果4335668条数据，对重试次数超过100的更新操作进行记录，发现更新操作出现大部分的重试，任务本身DB写操作的qps较低【都不需要通过控制台限制速率..】&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-案例2商品库存&quot;&gt;案例2：商品库存&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;商品库存与上述案例1一致，都是对数据记录进行加减操作，发现库存的更新方式如下：
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update 库存表
set stock=stock-1
where id=#{id}
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;直接使用数据库的排它锁就简单的避免了并发导致的丢失更新问题，之前提到的一次只有一个事务拥有资源的排它锁，并发的更新操作都试图占有资源的排它锁，当资源上存在排它锁时，其他更新操作需要等待锁的释放&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;相比案例1的解决方案，案例2的解决方式直接使用了MySQL InnoDB更新操作本身就拥有的排它锁，不需要额外的开销，而案例1不必要的查询操作以及多次的重试操作严重影响到了数据迁移的性能，所以案例1是反面例子..&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-案例3商品打标&quot;&gt;案例3：商品打标&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;随着上打标的qps上涨，出现达标更新数据丢失的情况
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;tags&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;16,32,233,22&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;itemState&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;hd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ai:4|nd:18&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;au&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;baoming&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;处理方案
    &lt;ol&gt;
      &lt;li&gt;乐观锁：采用CAS
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update TradeItem
set extra=#{extra}
where tradeItemId=#{tradeItemId} and extra=#{oldExtra}
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;这里使用长字符串做更新条件，会影响到SQL性能？？？&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;乐观锁：采用数据版本 
 表中新增version字段标识数据版本，作为数据更新的检查方式
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;update TradeItem
set extra=#{extra} , version=version+1
where tradeItemId=#{tradeItemId} and version=#{version}
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;此方案改造较大，还需要为表新增字段，而且采用乐观锁拥有这一律的弊端：重试带来的时间代价，一旦并发量上涨，某次更新操作的重试次数也会随之上涨，直接影响到暴露服务的响应时间。【限制重试次数能够一定程度上控制更新操作的响应时间，但是仍然会出现更新丢失的现象（让调用方进行重试操作，分摊单次请求的响应时间？）】&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;悲观锁&lt;br /&gt;
更新丢失的根本原因是执行查询、修改两个操作之间数据被另一事务修改了，单纯的UPDATE操作其实也是进行着先查询后修改的操作，没有产生更新丢失是因为数据上存在排它锁（sql server则是更新锁），在执行期间并不允许其他修改。同理我们将要打标的商品记录加上排它锁或者更新锁就能解决问题。&lt;br /&gt;
MySQL:
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;start transaction;
SELECT extra
FROM TradeItem 
WHERE tradeItemId=#{tradeItemId}
FOR UPDATE;
UPDATE TradeItem 
SET extra = bdo.AddTag(tag,extra)
WHERE tradeItemId=#{tradeItemId};
commit;
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;SQL SERVER:&lt;/p&gt;
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;BEGIN TRANSACTION --开始一个事务
SELECT extra
FROM TradeItem WITH (UPDLOCK)
WHERE tradeItemId=#{tradeItemId}
UPDATE TradeItem 
SET extra = bdo.AddTag(tag,extra)
WHERE tradeItemId=#{tradeItemId}
COMMIT TRANSACTION --提交事务
&lt;/code&gt;&lt;/pre&gt;
        &lt;/div&gt;
        &lt;p&gt;该方案避免了重试带来的开销，同时使用排它锁（更新锁）也没有额外增加锁的开销【直接把commit写到sql里面会被raptor拦截，只能使用dateSource.getConnection设置自动提交为false后提交】&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;heading-悲观锁乐观锁的取舍&quot;&gt;悲观锁乐观锁的取舍&lt;/h2&gt;</content><author><name>{&quot;name&quot;=&gt;nil, &quot;job_title&quot;=&gt;nil, &quot;location&quot;=&gt;nil, &quot;email&quot;=&gt;nil, &quot;social_links&quot;=&gt;[{&quot;name&quot;=&gt;&quot;facebook&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;github&quot;, &quot;url&quot;=&gt;&quot;https://github.com/Tobi7&quot;}, {&quot;name&quot;=&gt;&quot;instagram&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;linkedin&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;stackoverflow&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;twitter&quot;, &quot;url&quot;=&gt;nil}, {&quot;name&quot;=&gt;&quot;vk&quot;, &quot;url&quot;=&gt;nil}]}</name></author><category term="mysql" /><summary type="html">数据库锁机制</summary></entry></feed>